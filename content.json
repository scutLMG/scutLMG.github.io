{"pages":[{"title":"","text":"中国2098-太阳照常升起，范文南 About随便整的一博客，没啥时间，要学习。有空就写点。","link":"/about/index.html"},{"title":"","text":"瞎扯 var gitalk = new Gitalk({ clientID: 'f9f87445f8be567cb055', clientSecret: '120a5a3c9fb951390aadae2b55909cdb6721ce28', id: '20210709', repo: 'selfTalk_db', owner: 'scutLMG', admin: \"scutLMG\", createIssueManually: true, distractionFreeMode: false, pagerDiraction: 'first', perPage: 50 }) gitalk.render('gitalk-container')","link":"/talktalk/index.html"},{"title":"test","text":"一点字","link":"/test/index.html"},{"title":"","text":"console.log(\"Test for judging\")","link":"/test/test.js"}],"posts":[{"title":"Crontab","text":"Crontab 是linux用于执行定时程序的工具。 主要有两类，系统任务调度和用户任务调度。 系统任务调度：系统周期性所要执行的工作，比如写缓存数据到硬盘、日志清理等。一般在 /etc/crontab 里，用户一般不修改这一个。 用户任务调度：用户定期要执行的工作，比如用户数据备份、定时邮件提醒等。用户可以用来定制自己的计划任务。据说保存在 /var/spool/cron 目录中。 没找到什么合适的文档，直接 man crontab 吧。 一些文档：crontab(8)，crontab(5)，crontab(1)，不如直接man。 命令参数-ucrontab -u usr 表示指定某用户的计划任务 -ecrontab -e 编辑某个用户的 crontab 文件内容。如果不指定用户，则表示编辑当前用户的 crontab 文件。 -lcrontab -l 显示某个用户的 crontab 文件内容，不指定用户，则当前。 -rcrontab -r 从目录中删除某个用户的 crontab 文件，不指定，则当前。（-i：删除时给予确认提示） 文件释义crontab 文件中，一行表一个任务，一行中有多个字段，前五个字段是时间设定，最后是命令段，命令段可以添加命令参数。 crontab 文件的文件头中，有一些执行路径、环境配置等，出问题的时候可以留意下。 时间字段：一共五个，含义依次为：分、时、日、月、星期几。 * 为通配，周日的值是0。 操作符有：* 取值范围内的所有数字，/ 每过多少个数字，- 从X到Z，, 散列数字。 实例： 123* * * * * command #每分钟一次3,15 8-11 */2 * * command #每两天，在8-11点的3分和15分时执行* 7-22/5 * * 6,0 command #每周六日，7-21点每5小时执行一次 命令生成器：因为crontab不提示命令对错，经常会写错，可以直接用生成器生成对照。 扩展时间字段有一些简单扩展 如：@reboot 每次重启，@yearly 每年，代替 0 0 1 1 * ，其他的有daily、hourly等。 1@daily /home/maverick/bin/cleanup-logs &quot;day started&quot; 文件头crontab 的文件头可以有环境配置 123456# use /bin/sh to run commands, no matter what /etc/passwd saysSHELL=/bin/sh# mail any output to 'five', no matter whose crontab this isMAILTO=five#CRON_TZ=China 路径问题用户个人的 crontab 路径是 /home/yourUsrName/ ，写相对路径，输出文件时要注意。如果不确定默认路径，写一个脚本执行一遍定时文件创建，查看输出到哪个位置。 日志一般是默认没开的。 1234sudo vim /etc/rsyslog.d/50-default.confcron.* /var/log/cron.log #将cron前面的注释符去掉sudo service rsyslog restart #重启rsyslogsudo service cron restart #重启cron 重定向任务调度执行完毕后，系统会输出日志、发送通知邮件（现在好像不指定就不会发），如果是高频任务，日志量可能会很大，最好将日志输出忽略，标准输出重定向。 12&gt;/dev/null 2&gt;&amp;1&gt; /home/username/crontab.log 示例定时创建文件12crontab -e* 6 * * * touch test.log 定时屏幕输出如果编写 .sh ，在 crontab 内调用，未必能执行成功。如下： 123#!/bin/shnotify-send &quot;hello world!&quot;touch test.log 1* * * * * sh /home/five/hello.sh 大概率什么提示都看不到，而且 crontab 还没有错误提示。实际上 .sh 脚本会被执行，文件是会创建的。只是 notify-send 的屏幕输出没有。 解决类似问题，如果是单条提示，可以 1* * * * * XDG_RUNTIME_DIR=/run/user/$(id -u) notify-send &quot;What you want to say.&quot; 如果是脚本内调用量 notify-send ，那么在 .sh 里的环境变量写： 123#!/bin/shexport XDG_RUNTIME_DIR=/run/user/$(id -u)export DISPLAY=:0 我也不知道为什么，但是写了就可以。参考自：stackoverflow ，askubuntu 执行自动备份（rsync）10 6 1 * * rsync -au /source/path /destination/path 执行python脚本指定python解释器的路径。其他什么php也大差不差。 10 9 * * * /usr/bin/python /opt/py/test.py &gt;&gt; /opt/py/cronTest.log 其他注意 crontab 中，% 表换行，需要使用时注意转义 \\ 。 慎用 crontab -r ，毕竟算是 rm-rf 。","link":"/2021/11/01/Crontab/"},{"title":"Git 版本控制","text":"版本控制 本地版本控制只对本地的文件进行版本控制 集中式代表性的是 SVN ，代码文件存放在中央服务器 分布式目前代表性的是 Git ，每个人都有代码副本。Git 的创始人是 Linus ，都用 Linux 了，何不再试试 Git 呢？而且，Fuck you, Nvida ! 如果不想敲命令了，还有GUI可以用。 Git文档 安装Window：下载官网的包。或者镜像下载。 Linux： 1234567891011sudo apt install git-all #安装git建议的包以及依赖项，如git-doc, git-gui, gitk, gitweb等等sudo apt install git #最小安装# 或者编译安装wget heeps://github.com/git/git/archive/v2.xx.x.tar.gztar -xvf v2.xx.x.tar.gzcd git-2.xx.xmake prefix=/usr/local/git install #安装git至路径vim /etc/profilePATH=$PATH:/usr/local/git/binexport PATH #编辑环境变量 初始配置git自带git config对git外观和行为配置。一共有三重配置信息。 /etc/gitconfig 文件: 包含系统上每一个用户及他们仓库的通用配置。 如果在执行 git config 时带上 --system 选项，那么它就会读写该文件中的配置变量。 （由于它是系统配置文件，因此你需要管理员或超级用户权限来修改它。） ~/.gitconfig 或 ~/.config/git/config 文件：只针对当前用户。 你可以传递 --global 选项让 Git 读写此文件，这会对你系统上所有的仓库生效。 当前使用仓库的 Git 目录中的 config 文件（即 .git/config）：针对该仓库。 你可以传递 --local 选项让 Git 强制读写此文件，虽然默认情况下用的就是它。（当然，你需要进入某个 Git 仓库中才能让该选项生效。） 安装完成后，首先有完成用户名和邮箱地址设置 12345git config --global user.name &quot;name&quot;git config --global user.email email@example.comgit config --list #检查git的配置git config &lt;key&gt; #检查某一项配置 常用命令1234567891011121314151617181920212223242526272829git init #初始化git仓库git clone /path/to/repo #克隆本地仓库git clone username@host:/path/to/repo #克隆远端仓库git add &lt;filename&gt; #提出更改，添加到暂存区git commit -m &quot;代码提交信息&quot; #提交到HEADgit push oringin master #推送到远端仓库，master分支git remote add oringin &lt;server&gt; #链接到远程服务器git pull #更新本地，并合并远端改动git merge &lt;branch&gt; #合并分支到当前分支，手动处理冲突使用addgit diff &lt;sourc_brach&gt; &lt;target_branch&gt; #查看差异git tag &lt;tag_name&gt; &lt;id&gt; #创建标签git log #获取提交IDgit checkout -- &lt;filename&gt; #当前操作有误时，将HEAD内容替换到工作目录中git fetch oringin git reset --hard oringin/master #以上为丢弃本地改动，获取新版，并将本地主分支指向新版本 概念工作流工作目录、暂存区、HEAD 分支冲突处理 tips12gitk #内置图形化gitgit config corlor.ui true #彩色输出","link":"/2021/06/01/Git%20%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"},{"title":"GitHub Action入门指南","text":"作为github的new ass，一般日常使用就是pull，push，拉点别人代码看看，CI之类的很少用，GitHub 把抓取代码、运行测试、登录远程服务器，发布到第三方服务等这些操作称为 actions。 操作在不同项目里面是类似的，GitHub 允许开发者把操作写成独立的脚本文件，存放到代码仓库，使得其他开发者可以引用。整个持续集成过程，成了一个 actions 的组合。 在 GithHub 市场里，可以直接拉别人提交的 actions ,或者 awesome actions 里也有好东西 基础workflow （工作流程）：持续集成一次运行的过程，就是一个 workflow。每个 Workflow 最多可以执行 72 小时,创建 YAML 文件来创建 Workflow 配置。 job （任务）：一个 workflow 由一个或多个 jobs 构成，含义是一次持续集成的运行，可以完成多个任务。每个 Workflow 中的 job 最多可以执行 6 个小时 step（步骤）：每个 job 由多个 step 构成，一步步完成。 action （动作）：每个 step 可以依次执行一个或多个命令（action）。在一个存储库的所有 Action 中，一个小时最多可以执行 1000 个 API 请求 workflowworkflow 文件就是 actions 的配置文件，用 yaml 格式的 .yml 书写，存放在代码仓库的.github/workflows目录，一个库可以有多个 workflow 文件。 字段介绍如下： name：Workflow 的名称，会显示在 Action 页，忽略该字段，则默认为相对根目录的工作流文件路径。 on：就是 Actions 触发器，可以绑定多个事件。也支持外部事件，定时运行等。同时，可以指定限定分支/标签的事件触发响应。也支持使用活动类型。更多直接查官方文档 123456789101112131415on: pushon: [push,pull_request,release]on: push: branches: - 'main'on: pull_request: # Sequence of patterns matched against refs/heads branches-ignore: - 'mona/octocat' - 'releases/**-alpha'on: label: types: [created, edited] jobs：一个 Workflow 由一个或多个 jobs 构成，含义是一次持续集成的运行，可以完成多个任务。 通过 job 的 id 定义一个 job，每个 job 必须要有一个 id。大致如下： name 指定 job 的名称，在 GitHub 中会显示 runs-on 指定运行环境，必填。 steps 指定运行步骤，可以包含多步步骤，可以指定多种字段：name，env，run，if，uses，shell 等，更多参看官方文档。 env 指定环境，在整个工作流程或者某一个步骤中也可以设定，具体看需求和控制范围而定。 needs 指定 job 的依赖。 if 可以用条件来组织 job 的运行 123456789jobs: first_job_id: name: first_job_name runs-on: ubuntu-18.04 second_job_id: name: second_job_name runs-on: ubuntu-latest needs: first_jod_id steps: steps：指定运行步骤，可以包含多步步骤，可以指定多种字段：name，env，run，if，uses，shell 等，更多参看官方文档。可以运行命令行命令，环境配置命令，另一端 action等。在自己的运行器环境内运行，可访问工作空间、文件系统，也就是说，step 之间不会保留对环境变量的修改。 name env 配置环境 run 执行命令 if 条件控制 uses 可以直接引用其他的 actions shell 指定 shell 类型 环境矩阵如果需要多个编译环境，可以写个矩阵 1234567runs-on: ${{ matrix.os }}strategy: matrix: os: [ubuntu-16.04, ubuntu-18.04] node: [8, 10]steps: ...... 实战hexo自动部署为例这里参照了 Hexo Action 给出的实例。 准备工作 在源文件库下的 .github 文件夹下，创建 workflows 文件夹，在内添加 deploy.yml ，内容见下一小节 创建新密钥： 12345ssh-keygen -t rsa -f ~/.ssh/id_rsa_x -C &quot;yourmail@xxx.com&quot;cat ~/.ssh/id_rsa_x.pub# This is the public keycat ~/.ssh/id_rsa_x# This is the private key 部署密钥，将公钥放到网页托管仓库（即xx.github.io）的 Setting / Deploykey 内，私钥要复制到网页代码源仓库（即私有库）的 Setting / Secrets / Actions 内，在 Action secrets 内 New 一个 reposity secret，名字是 DEPLOY_KEY （其他名字也可以，在 deploy.yml 内相应修改即可。）复制包括 BEGIN OPENSSH PRIVATE KEY 和 END OPENSSH PRIVATE KEY。 这几步主要是配置 GitHub 的工作环境，因为类似本地环境，所以同样需要一对公钥 + 私钥用于仓库间的加密传输。当 GitHub Action 执行 hexo g -d 时，用私钥 DEPLOY_KEY 加密，GitHub 用网站文件仓库的公钥进行验证。整个流程就完成了。 yml代码12345678910111213141516171819202122232425262728293031323334353637383940name: Deployon: [push]jobs: build: runs-on: ubuntu-latest name: A job to deploy blog. steps: - name: Checkout uses: actions/checkout@v1 with: submodules: true # Checkout private submodules(themes or something else). # Caching dependencies to speed up workflows. (GitHub will remove any cache entries that have not been accessed in over 7 days.) - name: Cache node modules uses: actions/cache@v1 id: cache with: path: node_modules key: ${{ runner.os }}-node-${{ hashFiles('**/package-lock.json') }} restore-keys: | ${{ runner.os }}-node- - name: Install Dependencies if: steps.cache.outputs.cache-hit != 'true' run: npm ci # Deploy hexo blog website. - name: Deploy id: deploy uses: sma11black/hexo-action@v1.0.3 with: deploy_key: ${{ secrets.DEPLOY_KEY }} user_name: your github username # (or delete this input setting to use bot account) user_email: your github useremail # (or delete this input setting to use bot account) commit_msg: ${{ github.event.head_commit.message }} # (or delete this input setting to use hexo default settings) # Use the output from the `deploy` step(use for test action) - name: Get the output run: | echo &quot;${{ steps.deploy.outputs.notify }}&quot; 代码解析 step1是获取源码 step2是缓存压缩 node_modules，避免每次下载一次，加快部署速度，每次部署时，解压使用，七天内没有使用才会删除。 step3安装相关依赖，也即执行 npm install ，不过 npm ci 用于自动化环境、测试平台、持续集成和部署。跳过某些面向用户的功能，比常规的 npm 安装快。也比常规安装更严格，可以帮助捕获由大多数 npm 用户的增量安装的本地环境引起的错误或不一致。 step4部署 hexo，这里引用了 hexo action ，需要配置的是放在源代码仓库的私钥名称，用户名、邮箱和反馈信息 最后是 action 的输出打印。 错误一般来说配置好是没有问题的，如果提示 denied to deploy key，一般就是公钥放错地方了。 还有就是站点配置文件的 repo 写错了，一般来说本地能部署上传，action 的配置也不会有什么错，有错就是 action 没写对。 参考github-docs-about-custom-actions Events that trigger workflows Marketplace GitHub actions awesome actions GitHub Actions Market: Checkout Hexo action","link":"/2022/03/02/Github%20Action%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/"},{"title":"HTML简要笔记","text":"了解HTML的基本元素以及属性后，常用的其实也就其中的一些，大体有一个框架性的了解就行了。 写详细的也没必要，教程那么多，超越不了，也不适合自己用，流水账式写完岂不是编字典？不如要用再查。 &lt;head&gt;head元素不在页面中显示，主要内容包含元数据meta，标题title等。 &lt;title&gt;title仅为网页文档添加标题（整个HTML文档），与h1区别，h1为body添加标题。同时，title作为书签的推荐命名以及搜索引擎抓取的搜索结果。 &lt;meta&gt;一般用于指定文档字符编码，&lt;meta charset='utf-8'&gt;等。 还包含name，content特性，指定元素类型以及内容。 12&lt;meta name=&quot;author&quot; content=&quot;Ivy&quot;&gt;&lt;meta name=&quot;description&quot; content=&quot;A front-end note.&quot;&gt; 其中的description可以在搜索引擎中显示。 其他head中常见的还塞了&lt;link&gt;,&lt;script&gt;等，以链接到图表、样式表等等。 页面结构页面语义结构为构建网页布局，一般地，我们需要页眉、导航、正文主体、侧边栏与页脚等页面结构，需要使用一系列明确的标签，如下。 &lt;header&gt;：页眉。 &lt;nav&gt;：导航栏。 &lt;main&gt;：主内容。主内容中还可以有各种子内容区段，可用&lt;article&gt;、&lt;section&gt; 和 &lt;div&gt; 等元素表示。 &lt;aside&gt;：侧边栏，经常嵌套在 &lt;main&gt; 中。 &lt;footer&gt;：页脚。 以下为上述标签的综合实例：当然还要加点CSS的 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;Showing how to use HTML for structuring content&lt;/title&gt; &lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;header&gt;&lt;h1&gt;页眉标题&lt;/h1&gt;&lt;/header&gt; &lt;nav&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/&quot;&gt;MDN Web Docs&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;https://validator.w3.org/&quot; title=&quot;检查页面并返回错误报告&quot;&gt;HTML验证服务&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;form&gt; &lt;input type=&quot;search&quot; name=&quot;q&quot; placeholder=&quot;要搜索的内容&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;搜索&quot;&gt; &lt;/form&gt; &lt;/nav&gt; &lt;main&gt; &lt;article&gt; &lt;h2&gt;定风波·莫听穿林打叶声&lt;/h2&gt; &lt;p&gt;苏轼 〔宋代〕&lt;/p&gt; &lt;p&gt;三月七日，沙湖道中遇雨，雨具先去，同行皆狼狈，余独不觉。已而遂晴，故作此。&lt;br&gt; 莫听穿林打叶声，何妨吟啸且徐行。&lt;br&gt;竹杖芒鞋轻胜马，谁怕？一蓑烟雨任平生。&lt;br&gt; 料峭春风吹酒醒，微冷，山头斜照却相迎。&lt;br&gt;回首向来萧瑟处，归去，也无风雨也无晴。&lt;br&gt;&lt;/p&gt; &lt;/article&gt; &lt;aside&gt; &lt;h3&gt;注释&lt;/h3&gt; &lt;p&gt;宋神宗元丰五年（1082）的三月七日，在沙湖道上...&lt;/p&gt; &lt;/aside&gt; &lt;/main&gt; &lt;footer&gt; &lt;p&gt; © 我瞎写的 &lt;/p&gt; &lt;/footer&gt; &lt;/body&gt; &lt;/html&gt; 其他分隔结构 &lt;div&gt; &lt;span&gt; 这两个无语义元素，其中&lt;div&gt;是块级元素，&lt;span&gt;是内联元素（区别：换不换行）。当需要一组元素修饰一些单独的实体以提供CSS与JS的单一响应时，或不需要对修饰实体增加不必要的特定结构含义时，就可以使用了。 &lt;br&gt;，换行元素。 &lt;hr&gt;，插入水平分割线。 文字处理内容上的语义结构完成页面结构的布局后，对其内容在语义上需要进一步分离（如标题，分段等），当然，很多时候通过样式来进行视觉上的区分。尽管我们可以使用&lt;span&gt;等无语义元素加上样式来使内容看上去像特定语义块，但这对整个网页的分析并无益处。 常用文字语义元素 &lt;h1&gt;-&lt;h6&gt;：多级标题。 &lt;p&gt;：段落 &lt;ul&gt;,&lt;ol&gt;,&lt;li&gt;：列表的无序（unordered）、有序(ordered list)以及列表条目。有、无序是可以互相嵌套的，当然，大部分元素都是可以互相嵌套的。 &lt;em&gt;,&lt;strong&gt;：语义强调，斜体强调（语气？）以及粗体特别强调。 &lt;b&gt;,&lt;i&gt;,&lt;u&gt;：一些很旧的元素，用于粗体、斜体和下划线，不记得也没关系的东西，已经不重要了。 一些少用但必要的内容语义结构 &lt;dl&gt;,&lt;dt&gt;,&lt;dd&gt;：描述列表。 1234567&lt;dl&gt; &lt;dt&gt;描述的第一项&lt;/dt&gt; &lt;dd&gt;第一项的描述&lt;/dd&gt; &lt;dt&gt;第二项&lt;/dt&gt; &lt;dd&gt;第二项的描述一&lt;/dd&gt; &lt;dd&gt;第二项的描述二&lt;/dd&gt;&lt;/dl&gt; 描述的第一项 第一项的描述 第二项 第二项的描述一 第二项的描述二 引用及引文，引用有块引用与行引用。 &lt;blockquote&gt;：块引用，包住引用的内容，使用cite属性指向引用的资源。（点不了，指向有啥用？） &lt;q&gt;：同上，只不过是在行内。 缩略，使用&lt;addr&gt;包裹缩略语，在元素内的属性title写缩略的解释。 上下标，使用&lt;sup&gt;和&lt;sub&gt;包裹。 代码块，使用&lt;code&gt;，还有一些更不常用的如：&lt;pre&gt;，&lt;var&gt;，&lt;kbd&gt;，&lt;samp&gt;。 超链接既然是互联网的产物，链接肯定是极其重要的一环。 元素&lt;a&gt;元素&lt;a&gt;的内容在链接解析成功后，作为链接入口。而内容可以不止是文本，嵌套&lt;img&gt;等块级元素也是可以的。 属性： herf属性，包含指向网址。 title属性，补充信息，悬停时显示。 路径使用url统一资源定位符作为位置定义。 上级目录：../xx 子目录：son/xx 文档片段：xx.html#Mailing_address，链接到文档内的特定部分，通过对目标部分的元素分配id属性来标记。 绝对与相对的选取，一般地，多使用相对链接，可以减少浏览器通过DNS的查找，但是要注意，相对链接会随着文档结构的改变而改变。 多媒体图&lt;img&gt;元素 src属性内放置图片路径（绝对/相对）。 alt属性，作为备选内容，在图片不显示时输出。同时作为图片的描述。 width,height：定义大小。 title：悬停提示。 如果需要图（或音视频）搭配文字，可以使用&lt;img&gt;和&lt;p&gt;构建，或使用&lt;figure&gt;和&lt;figcaption&gt;，前者包含整个多媒体流，后者内包裹文本。 音视频&lt;video&gt;与&lt;audio&gt;，但一般使用其他插件。具体见video与audio在MDN上的详细页面。 其他嵌入用的少，不写了，需要再去查iframe,embed,object等等元素。 表格展现数据。实际上也不常用，而且很长很多。但还是要写！我要死了！写这个太无聊了！ 表格使用的元素比较多，&lt;table&gt;,&lt;tr&gt;,&lt;td&gt;,&lt;th&gt;,&lt;col&gt;,&lt;colgroup&gt;,&lt;caption&gt;,&lt;thead&gt;,&lt;tfoot&gt;,&lt;tbody&gt;，还可以嵌套。 一般的属性有colspan,rowspan,span,scope,id,headers。 好吧，一一记录下。 基本结构使用&lt;table&gt;创建表格，&lt;tr&gt;创建每行表格，&lt;td&gt;表示每个格子，格子也可以使用&lt;th&gt;用以表明该格为标题（行/列）。 结构方面，可以在table下使用&lt;caption&gt;来为表格创建标题。也可以使用&lt;thead&gt;,&lt;tfoot&gt;,&lt;tbody&gt;来区分表格结构，元素名字已经不言自明。 修饰属性属性有很多，出去可以通过css样式修饰的之外，主要为了实现表格元素标记和非常规的表格模式。 为跨越多行/列，可以令&lt;td&gt;,&lt;th&gt;的属性colspan,rowspan为一个无单位数值，即可跨越相应的格子数。 为指明&lt;th&gt;是行还是列标题，利用scope属性指明值为row或col甚至复杂表格的rowgroup等。 单元格与标题的联系还可以用id和headers来创造。在&lt;th&gt;中创建唯一的id属性值，在&lt;td&gt;的headers属性中，包含’所有‘属于的标题的id值。 结尾笔记基本上包含了HTML常用的要点。最后，要检查代码，在Markup Validation Service上提交文档即可返回错误报告，一般来说，浏览器都支持宽松的特性，所以瞎写也问题不大。","link":"/2019/10/14/HTML%E7%AE%80%E8%A6%81%E7%AC%94%E8%AE%B0/"},{"title":"Javascript面向对象","text":"Javascript面向对象。原型与闭包，异步等。 面向对象不可能少了面向对象，不过JS的和Java、C、C++的太不一样，不得不写一写。 一些注意： 对象的属性值可以是任何的数据类型，也可以是个函数：（也称之为方法） 对象中的属性值，也可以是一个对象。 对象的值是保存在堆内存中的，而对象的引用（即变量）是保存在栈内存中的。如果两个变量保存的是同一个对象引用，当一个通过一个变量修改属性时，另一个也会受到影响。 对象基础对象的属性、方法的表示法有点表示法和括号表示法两种，区别在于点表示法只能接受字面量的成员的名字，不接受变量作为名字，所以括号表示法不仅可以动态的去设置对象成员的值，还可以动态的去设置成员的名字。 JS的this，关键字this指向了当前代码运行时的对象，当使用构造器动态创建对象时，这可以保证代码上下文改变时变量值的正确性。 基于原型与其他的面向对象语言不太一样，当OOP定义类并以此创建对象实例时，类的属性、方法会被复制到实例中。而JS不进行复制，它通过对象实例与构造器之间的链接，当实例属性被调用，则上溯原型链，找到对应的属性与方法。 这一链接是__proto__属性，由构造函数的prototype属性派生出来的。 构造函数 类似于其他语言中的“类”。 12345678910111213//一个构造函数function Construct(var){ this.var = var; this.reaction = function(){};}//创建实例var example1 = new Construct('hello')//另一种var example2 = new Object();//继承的方式var example3 = Object.create(example1); 原型 函数都有特殊属性：原型prototype 123456789101112131415161718192021222324252627282930313233function sth(){}sth.prototype.add = &quot;thing&quot;;var sthmore = new sth();sthmore.prop = &quot;other&quot;;console.log(&quot;sth.prototype: &quot; + sth.prototype);console.log(&quot;sth.__proto__: &quot; + sth.__proto__);console.log(&quot;sth.__proto__.__proto__: &quot; + sth.__proto__.__proto__);console.log(&quot;sthmore.prototype: &quot; + sthmore.prototype);console.log(&quot;sthmore.__proto__: &quot; + sthmore.__proto__);console.log(&quot;sthmore.__proto__.__proto__: &quot; + sthmore.__proto__.__proto__);console.log(&quot;sthmore.__proto__.__proto__.__proto__: &quot; + sthmore.__proto__.__proto__.__proto__);console.log(&quot;sthmore.prop: &quot; + sthmore.prop);console.log(&quot;sthmore.add: &quot; + sthmore.add);console.log(&quot;sth.prop: &quot; + sth.prop);console.log(&quot;sth.add: &quot; + sth.add);console.log(&quot;sth.prototype.prop: &quot; + sth.prototype.prop);console.log(&quot;sth.prototype.add: &quot; + sth.prototype.add);/*sth.prototype: [object Object]sth.__proto__: function () { [native code] }sth.__proto__.__proto__: [object Object]sthmore.prototype: undefinedsthmore.__proto__: [object Object]sthmore.__proto__.__proto__: [object Object]sthmore.__proto__.__proto__.__proto__: nullsthmore.prop: othersthmore.add: thingsth.prop: undefinedsth.add: undefinedsth.prototype.prop: undefinedsth.prototype.add: thing*/ 先要搞清楚，对象的属性__prototype__的表现与函数的默认属性prototype一致，实际上__prototype__引用了创建该对象的函数（构造函数）的prototype，不过这个对象属性是一个隐藏属性，一般不被希望使用。有了大致的原型认识，再从对象说起。 函数与对象感觉前面写得太乱了，写完后面看看要不要删掉前面好了。 在Javascript中，除去值类型（undefined、number、string、boolean）外的一切都是对象。 那么，函数是对象，而对象是由函数创建的。 异步JS","link":"/2019/10/14/Javascript%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"title":"cURL入门用法","text":"curl是一种支持多种协议的命令行工具，发出网络请求，得到和提取数据，显示在”标准输出”（stdout）上面。 参数无任何参数时，curl 就是发出 GET 请求。 curl https://www.example.com 上面命令向www.example.com发出 GET 请求，服务器返回的内容会在命令行输出。 -A 指定User-Agent-A 参数指定客户端的用户代理标头，即 User-Agent。curl 的默认用户代理字符串是curl/[version]。 1curl -A 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.100 Safari/537.36' https://google.com 上面命令将 User-Agent 改成 Chrome 浏览器。 1curl -A '' https://google.com 上面命令会移除 User-Agent 标头。 也可以通过-H参数直接指定标头，更改 User-Agent。 1curl -H 'User-Agent: php/1.0' https://google.com -b 发送Cookie-b 参数用来向服务器发送 Cookie。 1curl -b 'foo=bar' https://google.com 上面命令会生成一个标头 Cookie: foo=bar，向服务器发送一个名为 foo、值为 bar 的 Cookie。 1curl -b 'foo1=bar;foo2=bar2' https://google.com 上面命令发送两个 Cookie。 1curl -b cookies.txt https://www.google.com 上面命令读取本地文件 cookies.txt，里面是服务器设置的 Cookie（参见 -c 参数），将其发送到服务器。 -c Cookie写入-c 参数将服务器设置的 Cookie 写入一个文件。 1curl -c cookies.txt https://www.google.com 上面命令将服务器的 HTTP 回应所设置 Cookie 写入文本文件cookies.txt。 -d 发送 POST 请求体-d参数用于发送 POST 请求的数据体。 123curl -d'login=emma＆password=123'-X POST https://google.com/login# 或者curl -d 'login=emma' -d 'password=123' -X POST https://google.com/login 使用-d参数以后，HTTP 请求会自动加上标头Content-Type : application/x-www-form-urlencoded。并且会自动将请求转为 POST 方法，因此可以省略-X POST。 -d参数可以读取本地文本文件的数据，向服务器发送。 1curl -d '@data.txt' https://google.com/login 上面命令读取data.txt文件的内容，作为数据体向服务器发送。 –data-urlencode 自动 URL 编码。--data-urlencode参数等同于-d，发送 POST 请求的数据体，区别在于会自动将发送的数据进行 URL 编码。 1curl --data-urlencode 'comment=hello world' https://google.com/login 上面代码中，发送的数据hello world之间有一个空格，需要进行 URL 编码。 -e 设置 HTTP 的标头-e参数用来设置 HTTP 的标头Referer，表示请求的来源。 1curl -e 'https://google.com?q=example' https://www.example.com 上面命令将Referer标头设为https://google.com?q=example。 -H参数可以通过直接添加标头Referer，达到同样效果。 1curl -H 'Referer: https://google.com?q=example' https://www.example.com -F 上传二进制文件-F参数用来向服务器上传二进制文件。 1curl -F 'file=@photo.png' https://google.com/profile 上面命令会给 HTTP 请求加上标头Content-Type: multipart/form-data，然后将文件photo.png作为file字段上传。 -F参数可以指定 MIME 类型。 1curl -F 'file=@photo.png;type=image/png' https://google.com/profile 上面命令指定 MIME 类型为image/png，否则 curl 会把 MIME 类型设为application/octet-stream。 -F参数也可以指定文件名。 1curl -F 'file=@photo.png;filename=me.png' https://google.com/profile 上面命令中，原始文件名为photo.png，但是服务器接收到的文件名为me.png。 -G 构造 URL 的查询字串-G参数用来构造 URL 的查询字符串。 1curl -G -d 'q=kitties' -d 'count=20' https://google.com/search 上面命令会发出一个 GET 请求，实际请求的 URL 为https://google.com/search?q=kitties&amp;count=20。如果省略--G，会发出一个 POST 请求。 如果数据需要 URL 编码，可以结合--data--urlencode参数。 1curl -G --data-urlencode 'comment=hello world' https://www.example.com -H 添加 HTTP 请求的标头-H参数添加 HTTP 请求的标头。 1curl -H 'Accept-Language: en-US' https://google.com 上面命令添加 HTTP 标头Accept-Language: en-US。 1curl -H 'Accept-Language: en-US' -H 'Secret-Message: xyzzy' https://google.com 上面命令添加两个 HTTP 标头。 1curl -d '{&quot;login&quot;: &quot;emma&quot;, &quot;pass&quot;: &quot;123&quot;}' -H 'Content-Type: application/json' https://google.com/login 上面命令添加 HTTP 请求的标头是Content-Type: application/json，然后用-d参数发送 JSON 数据。 -i 打印回应的 HTTP 标头-i参数打印出服务器回应的 HTTP 标头。 1curl -i https://www.example.com 上面命令收到服务器回应后，先输出服务器回应的标头，然后空一行，再输出网页的源码。 -I-I参数向服务器发出 HEAD 请求，然会将服务器返回的 HTTP 标头打印出来。 1curl -I https://www.example.com 上面命令输出服务器对 HEAD 请求的回应。 --head参数等同于-I。 1curl --head https://www.example.com -k 跳过 SSL 检测-k 参数指定跳过 SSL 检测。 1curl -k https://www.example.com 上面命令不会检查服务器的 SSL 证书是否正确。 -L 请求跟随服务器的重定向-L参数会让 HTTP 请求跟随服务器的重定向。curl 默认不跟随重定向。 1curl -L -d 'tweet=hi' https://api.twitter.com/tweet –limit-rate 限制 HTTP 请求和回应的带宽，模拟慢网速--limit-rate用来限制 HTTP 请求和回应的带宽，模拟慢网速的环境。 1curl --limit-rate 200k https://google.com 上面命令将带宽限制在每秒 200K 字节。 -o 保存回应为文件（wget）-o参数将服务器的回应保存成文件，等同于wget命令。 1curl -o example.html https://www.example.com 上面命令将www.example.com保存成example.html。 -O-O 参数将服务器回应保存成文件，并将 URL 的最后部分当作文件名。 1curl -O https://www.example.com/foo/bar.html 上面命令将服务器回应保存成文件，文件名为bar.html。 -s 不输出错误和进度-s参数将不输出错误和进度信息。 1curl -s https://www.example.com 上面命令一旦发生错误，不会显示错误信息。不发生错误的话，会正常显示运行结果。 如果想让 curl 不产生任何输出，可以使用下面的命令。 1curl -s -o /dev/null https://google.com -S 指定只输出错误信息-S 参数指定只输出错误信息，通常与-s一起使用。 1curl -s -o /dev/null https://google.com 上面命令没有任何输出，除非发生错误。 -u 设置用户名和密码-u参数用来设置服务器认证的用户名和密码。 1curl -u 'bob:12345' https://google.com/login 上面命令设置用户名为bob，密码为12345，然后将其转为 HTTP 标头Authorization: Basic Ym9iOjEyMzQ1。 curl 能够识别 URL 里面的用户名和密码。 1curl https://bob:12345@google.com/login 上面命令能够识别 URL 里面的用户名和密码，将其转为上个例子里面的 HTTP 标头。 1curl -u 'bob' https://google.com/login 上面命令只设置了用户名，执行后，curl 会提示用户输入密码。 -v 输出通信过程-v 参数输出通信的整个过程，用于调试。 1curl -v https://www.example.com --trace参数也可以用于调试，还会输出原始的二进制数据。 1curl --trace - https://www.example.com -x 指定请求代理-x 参数指定 HTTP 请求的代理。 1curl -x socks5://james:cats@myproxy.com:8080 https://www.example.com 上面命令指定 HTTP 请求通过myproxy.com:8080的 socks5 代理发出。 如果没有指定代理协议，默认为 HTTP。 1curl -x james:cats@myproxy.com:8080 https://www.example.com 上面命令中，请求的代理使用 HTTP 协议。 -X 指定请求方法-X 参数指定 HTTP 请求的方法。 1curl -X POST https://www.example.com 上面命令对https://www.example.com发出 POST 请求。 -4 -6 ipv4 ipv612-4/--ipv4 curl -4 http://www.example.com 参考curl.1 the man page Curl Cookbook curl 的用法指南","link":"/2020/05/10/curl%E7%94%A8%E6%B3%95/"},{"title":"docker入门笔记","text":"docker 的入门笔记。时至今日，容器化技术已经不是什么新鲜东西了，docker 作为开源的应用容器引擎，易于部署，使用方便，一次打包，开箱即用，是值得学习一下的。不求精通，会用就够，记记流水帐。 docker 介绍容器化技术已经发展应用了很多年了，这里只简单记录一下 docker 。docker 早期使用的是 Linux 的 LXC 容器技术，而后转为自研的开源 runc 。相比于虚拟机，交付快，消耗低，管理方便。 namespace宿主机内运行了很多的容器，每个容器都要有类似于虚拟机一样的相互隔离的运行空间，但是容器技术是在一个进程内实现运行指定服务的运行环境，并且还可以保护宿主机内核不受其他进程的干扰和影响，如文件系统空间、网络空间、进程空间等，docker 是通过 Namespace 技术实现隔离的。 如 MNT Namespace 提供磁盘挂载点和文件系统的隔离能力，在容器里面是不能访问宿主机的资源，宿主机是使用了chroot技术把容器锁定到一个指定的运行目录里面。在宿主机里启动不同环境的容器，检查运行目录和内核就知道，共享内核但限制了运行目录。 PID Namespace：在每个容器内，同 Linux 系统一样，有 PID 为1的进程作为进程的父进程，PID Namespace 则是实现容器间进程隔离的技术（编号重复，主进程生成、子进程回收）如在宿主机中，父进程1下有debian容器， pid 为5777，容器内的父进程也是 pid 1，但对宿主机而言，debian容器的父进程的 pid 是5788。 123456789systemd(1)─┬─ModemManager(969)─┬─{ModemManager}(991) │ └─{ModemManager}(998) ├─colord(1681)─┬─{colord}(1690) │ └─{colord}(1701) ├─containerd(992)─┬─{containerd}(1029) │ ├─{containerd}(1030) │ ├─{containerd}(1107) │ ├─{containerd}(1114) │ └─{containerd}(5705) 可以使用 top 、ps -ef | grep [process] 、ps -ef | grep [PID] 等来在宿主机、容器内进行 PID 追踪验证。 还有 IPC 、UTS、Net、User 等 Namespace 技术，以后再写吧。 docker 组成docker 由主机、服务端、客户端、仓库、镜像、容器等组成。 Docker 主机(Host)：一个物理机或虚拟机，用于运行Docker服务进程和容器，也称为宿主机，node节点 Docker 服务端(Server)：Docker守护进程，运行docker容器 Docker 客户端(Client)：客户端使用docker 命令或其他工具调用docker API Docker 镜像(Images)：镜像可以理解为创建实例使用的模板 Docker 容器(Container)：容器是从镜像生成对外提供服务的一个或一组服务 docker 安装以 ubuntu 为例，其他 Linux 发行版也差不多，出错就看文档。Windows 下的 docker 安装直接下载一个包即可，还带桌面，实在没什么好说的。 卸载老版本，首次可跳过。 1sudo apt-get remove docker docker-engine docker.io containerd runc 更新并允许 apt 通过 HTTPS 使用存储库 123456sudo apt-get updatesudo apt-get install \\ ca-certificates \\ curl \\ gnupg \\ lsb-release d添加官方密钥 1curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg 设置存储库 123echo \\ &quot;deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu \\ $(lsb_release -cs) stable&quot; | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null 安装稳定版 12sudo apt-get updatesudo apt-get install docker-ce docker-ce-cli containerd.io docker-compose-plugin 验证安装 1sudo docker run hello-world 命令帮助1234567891011121314man dockerdocker --helpdocker COMMAND --helpman docker -COMMANDdocker versiondocker infodocker searchdocker pulldocker rundocker psdocker rmdocker logs 镜像命令12345678910111213141516171819Usage: docker image COMMANDManage imagesCommands: build Build an image from a Dockerfile history Show the history of an image import Import the contents from a tarball to create a filesystem image inspect Display detailed information on one or more images load Load an image from a tar archive or STDIN ls List images prune Remove unused images pull Pull an image or a repository from a registry push Push an image or a repository to a registry rm Remove one or more images save Save one or more images to a tar archive (streamed to STDOUT by default) tag Create a tag TARGET_IMAGE that refers to SOURCE_IMAGERun 'docker image COMMAND --help' for more information on a command. 列出的都是比较常用的。 12345docker image ls #和 docker images 一样docker search [image]docker pull [image]docker run -it ubuntu:20.04 /bin/bash #i交互操作，t终端，/bin/bash 进入交互式shelldocker commit 容器命令1234567891011121314151617181920docker psdocker start &lt;id&gt;docker run -ddocker stop &lt;id&gt;docker stop &lt;name&gt;docker attach &lt;id&gt; #进入后台运行（docker start -d）的容器#如果是以attach进入，在exit时，会导致容器的停止，要保持后台运行，使用exec进入docker exec &lt;id&gt; #to know more, use: docker exec --help docker export &lt;ID&gt; &gt; [name]docker export 1eee1e1e1e1f &gt; alpine.tar #导出容器快照到本地文件alpine.tarcat docker/alpine.tar | docker import - test/alpine:v1docker import http://example.com/exampleimage.tgz example/imagerepo #导入docker top &lt;container id&gt; docker top &lt;container names&gt; #查看容器进程docker inspect &lt;container id or names&gt; #查看底层信息，配置、状态等，以json形式docker rm &lt;id or names&gt;docker container update --restart=&lt;strategy&gt; &lt;container name&gt; #重置重启策略 交互端口映射12# -P 与 -p ：-P :是容器内部端口**随机**映射到主机的端口。-p : 是容器内部端口绑定到**指定**的主机端口。docker run -d -p 5000:5000 --name [name] [repository] [command] 容器互联可以创建新的网络，令多个容器之间互联 12345docker network create -d bridge [net-name]docker run -itd --name [name1] --network [net-name] [image] /bin/bashdocker run -itd --name [name2] --network [net-name] [image] /bin/bash# 在name1内ping name2 dockerfileDockerfile 是一个用来构建镜像的文本文件，创建 dockerfile ，官方文档 12FROM [base image]RUN [command] 构建镜像 1docker build -f /path/dockerfile 参考docker 官网 docker 文档 docker 中文网站 docker manuals 运维派docker dockerfile reference","link":"/2021/09/27/docker%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/"},{"title":"docker数据持久化","text":"docker的数据储存方案，volums bind mounts 为持久化方案，tmpfs mounts 是临时储存。 默认情况下，在容器内创建的所有文件都存储在可写容器层上。这意味着： 当该容器不再存在时，数据不会持久存在。 如果另一个进程需要数据，则很难将数据从容器中取出。容器的可写层与运行容器的主机紧密耦合。您无法轻松地将数据移动到其他地方。 写入容器的可写层需要存储驱动程序来管理文件系统。存储驱动程序提供了一个联合文件系统，使用 Linux 内核。与使用直接写入主机文件系统的数据卷相比，会降低性能。 Docker 为容器在主机上存储文件提供了两种选择，以便即使在容器停止后文件也能持久保存：卷 volumes 和绑定挂载 bind mounts 。 Docker 还支持将文件存储在主机内存中的容器。此类文件不会持久保存。即使用 tmpfs mount 将文件存储在主机的系统内存中。 方案区别无论您选择使用哪种类型的挂载，容器内的数据看起来都是一样的。它以目录或容器文件系统中的单个文件的形式公开。 可视化卷、绑定挂载和 tmpfs 挂载之间差异的是数据在 Docker 主机上的位置。 卷存储在由 Docker 管理的主机文件系统的一部分（Linux 上的 /var/lib/docker/volumes/）。非 Docker 进程不应修改文件系统的这一部分。卷是在 Docker 中持久化数据的最佳方式。 绑定挂载可以存储在主机系统的任何位置。它们甚至可能是重要的系统文件或目录。 Docker 主机或 Docker 容器上的非 Docker 进程可以随时修改它们。 tmpfs 挂载仅存储在主机系统的内存中，永远不会写入主机系统的文件系统。 volums卷由 Docker 创建和管理。使用 docker volume create 命令显式创建卷，或者 Docker 可以在容器或服务创建期间创建卷。 创建卷时，它存储在 Docker 主机上的目录中。当您将卷挂载到容器中时，此目录就是挂载到容器中的目录。类似于绑定挂载的工作方式，只是卷由 Docker 管理并且与主机的核心功能隔离。 给定的卷可以同时安装到多个容器中。当没有正在运行的容器使用卷时，卷仍然可供 Docker 使用，并且不会自动删除。您可以使用 docker volume prune 删除未使用的卷。 挂载一个卷时，它可能是命名的或匿名的。匿名卷在首次挂载到容器时没有明确的名称，因此 Docker 为它们提供了一个随机名称，该名称保证在给定的 Docker 主机中是唯一的。除了名称之外，命名卷和匿名卷的行为方式相同。 bind mounts绑定挂载绑定挂载：从 Docker 早期就可用。与卷相比，绑定挂载的功能有限。当您使用绑定挂载时，主机上的文件或目录会挂载到容器中。文件或目录由其在主机上的完整路径引用。该文件或目录不需要已经存在于 Docker 主机上。如果它尚不存在，则按需创建。绑定挂载非常高效，但它们依赖于具有特定目录结构的主机文件系统。（要部署到新主机的时候就麻烦了，移植性差，自己用的话性能倒是很不错），不能使用 Docker CLI 命令直接管理绑定挂载。绑定挂载允许访问敏感文件。 使用绑定挂载的一个副作用是，您可以通过在容器中运行的进程更改主机文件系统，包括创建、修改或删除重要的系统文件或目录。可能会产生安全隐患，包括影响主机系统上的非 Docker 进程。 tmpfs 挂载tmpfs 挂载不会持久保存在磁盘上，无论是在 Docker 主机上还是在容器内。它可以在容器的生命周期内被容器使用，用于存储非持久状态或敏感信息。例如，在内部，swarm 服务使用 tmpfs 挂载将机密信息挂载到服务的容器中。 绑定挂载和卷都可以使用 -v 或 –volume 标志挂载到容器中，但每个的语法略有不同。对于 tmpfs 挂载，您可以使用 –tmpfs 标志。我们建议对容器和服务使用 –mount 标志，用于绑定挂载、卷或 tmpfs 挂载，因为语法更清晰。 实例Volumes有两种方式，其中 –mount 更加明确和详细。最大的区别是 -v 语法将所有选项组合在一个字段中，而 –mount 语法将它们分开。 1234567891011#vdocker run -d \\ --name devtest \\ -v myvol2:/app \\ nginx:latest # mountdocker run -d \\ --name devtest \\ --mount source=myvol2,target=/app \\ nginx:latest -v 或 –volume：由三个字段组成，以冒号字符 (:) 分隔。字段必须按正确的顺序排列，每个字段的含义不是很明显。在命名卷的情况下，第一个字段是卷的名称，并且在给定的主机上是唯一的。对于匿名卷，省略第一个字段。第二个字段是文件或目录在容器中挂载的路径。第三个字段是可选的，是以逗号分隔的选项列表，例如 ro。 –mount由多个键值对组成，以逗号分隔，每个由一个 &lt;key&gt;=&lt;value&gt; 元组组成。 –mount 语法比 -v 或 –volume 更冗长，但键的顺序并不重要，标志的值更容易理解。如果需要指定卷驱动程序选项，则必须使用 –mount。 type 挂载类型，可以是 bind、volume 或 tmpfs。 source 挂载源。对于命名卷，这是卷的名称。对于匿名卷，此字段被省略。可以指定为 source 或 src。 detination 将安装在容器中的文件或目录路径作为其值。可以指定为destination、dst 或target。 readonly 选项（如果存在）会导致绑定挂载以只读方式挂载到容器中。可以指定为 readonly 或 ro。 可以多次指定的 volume-opt 选项，由选项名称及其值组成的键值对。 1234docker service create \\ --mount 'type=volume,src=&lt;VOLUME-NAME&gt;,dst=&lt;CONTAINER-PATH&gt;,volume-driver=local,volume-opt=type=nfs,volume-opt=device=&lt;nfs-server&gt;:&lt;nfs-path&gt;,&quot;volume-opt=o=addr=&lt;nfs-address&gt;,vers=4,soft,timeo=180,bg,tcp,rw&quot;' --name myservice \\ &lt;IMAGE&gt; 验证12345678910111213141516sudo docker volume lsDRIVER VOLUME NAMElocal c0afcad67ec7b5489fe1a44aaf405a477b14fa806b64353759685d3fc20256fcsudo docker inspect c0afcad67ec7b5489fe1a44aaf405a477b14fa806b64353759685d3fc20256fc[ { &quot;CreatedAt&quot;: &quot;2022-04-24T13:05:51+08:00&quot;, &quot;Driver&quot;: &quot;local&quot;, &quot;Labels&quot;: null, &quot;Mountpoint&quot;: &quot;/var/lib/docker/volumes/c0afcad67ec7b5489fe1a44aaf405a477b14fa806b64353759685d3fc20256fc/_data&quot;, &quot;Name&quot;: &quot;c0afcad67ec7b5489fe1a44aaf405a477b14fa806b64353759685d3fc20256fc&quot;, &quot;Options&quot;: null, &quot;Scope&quot;: &quot;local&quot; }] bind mounts 与 tmpfs一样用 mount，只是 type 不同，如： 1234docker run -d --name tomcat-bind --mount type=bind,source=/tmp,target=/user/local tomcat:latest#bind mounts use -v flag, absolute working directorydocker run -d -it --name=test-nginx -v /app/page:/usr/share/nginx/html nginx 参考docker-docs-volumes Manage data in Docker Use volumes docker数据持久化/共享—volume，bind-mount，tmpfs-mount","link":"/2021/09/27/docker%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"title":"docker镜像制作","text":"构建定制化docker的镜像，选择合适的 Linux 作为构建镜像的基础。 AlpineAlpine 是一个轻量的 Linux 发行版，适合制作镜像，本体大小只有58 MB 。使用 apk 包管理器。不过也可以使用 ubuntu 等 Linux 发行版来制作镜像，体积稍大，7080MB。所以可以从 Alpine 开始制作一个镜像。 123456docker run -it alpine:3.11.3 #用新的稳定发行版，一般来说，支持两年。apk --help #查看包管理器的支持。apk updatedcoker ps #在新建终端查看容器运行docker diff id #以id查找容器，查看文件更改历史 下以添加 hexo 为例，打包镜像。 123456789101112131415apk add nodejs npmnode -vnpm -vnpm i hexo-cli -ghexo -vnpm installcd /homemkdir bolgcd blogapk add githexo inithexo g# 新建终端docker container lsdocker commit id your_name/image_name:tag_name #打包成新镜像 alpine 实在是非常轻量，虽然构建镜像很适合，但是也会少了很多熟悉的工具，如果有打包好的镜像，可以直接下载对应 tag 的 alpine 镜像。比如 redis:4.0-alpine ，jenkins2.60.3-alpine（ 什么老古董）。 alpine 的 package repo 只有一个版本的包，这就意味着，当使用 alpine 构建特定镜像时，没有对应版本的包。比如 alpine3.4 中的 nodejs 包，只有6.7的。 选择 alpine 构建镜像前，如果对版本有特殊要求（不喜欢最新版的大坑），先去 alpine 官网的 packages 查一下。 其他发行版的体积大，但是版本管理确实舒服。个人用来应应急是无所谓的。 1234567891011#alpine 的常用命令apk # 包管理，下为参数，一般都是见词知意的。update, upgrade, #更新镜像源，升级软件包search, info, #查找与列出包信息add, del,automove #添加与删除，默认自动执行的清理rc- #服务管理，运行级的增删服务。我不用，所以不写。留个索引方便以后查#使用服务管理需要安装openrcapk add openrc#一般就是包管理和服务管理这两类，详见 alpine 官网 docs/User Handbook/Working With Alpine dockerfile构建镜像这种事，当然还是自动化一点更好。写个 dockerfile 比较方便。 以最简单的 hello world 镜像构建为例。 1234FROM scratch # base on scrstchCOPY hello /CMD [&quot;/hello&quot;] 太简单了。再写几个 12345FROM node:8.4COPY . /testWORKDIR /testRUN npm install --registry=https://registry.npm.taobao.orgEXPOSE 5000 123456ROM openjdk:8-jre # jar包基于jdk ,war包基于tomcatWORKDIR /appADD demo-0.0.1-SNAPSHOT.jar app.jar # 将上下文中 jar包复制到 /app目录下，并且重命名为app.jarEXPOSE 8081 # 暴露端口ENTRYPOINT[ &quot;java&quot; , &quot;-jar&quot; ] # 启动应用固定命令CMD[&quot;app.jar&quot;] # 动态传递jar包名 项目根目录下，可以新建一个 .dockerignore ，逐行写入不需要打包的文件。 以后有需求再加点实例吧。 常用指令参考文档 FROM 指令初始化一个新的构建阶段并为后续指令设置基本镜像。有效的 Dockerfile 必须以 FROM 指令开头。（除非是 ARG 开头，FROM 指令支持在第一个 FROM 之前出现的 ARG 指令声明的变量） 12ARG CODE_VERSION=latestFROM base:${CODE_VERSION} RUN 有两种形式： RUN command（shell形式，命令在shell中运行，Linux默认为/bin/sh -c，Windows默认为cmd /S /C）， RUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;] (执行形式)， RUN 指令将在当前图像之上的新层中执行任何命令并提交结果。生成的提交图像将用于 Dockerfile 中的下一步。exec 形式可以避免 shell 字符串修改，并使用不包含指定 shell 可执行文件的基本映像运行命令。 CMD 的主要目的是为正在执行的容器提供默认值。这些默认值可以包括可执行文件，也可以省略可执行文件，在这种情况下，还必须指定 ENTRYPOINT 指令。只会生效一个，所以写多个也只有最后一个生效。 LABEL 指令将元数据添加到镜像，是键值对。 EXPOSE 指令指定 Docker 容器在运行时监听的网络端口。可以指定端口监听 TCP 还是 UDP，如果不指定协议，则默认为 TCP。端口暴露与否视 RUN 指令决定。 ENV 键值对，指定环境变量，可被后续调用。 COPY 和 ADD，COPY 复制主机或前阶段（–from）的文件或目录生成新的镜像层（不解压，不能访问网络资源），ADD 相似，不过支持使用 URL，tar 文件自动解压。 VOLUME 用于指定持久化目录（指定此目录可以被挂载出去）。 WORKDIR 工作目录，类似于cd命令。 docker-compose如果一个项目需要用到多个容器（常有的事），那么容器的编排就十分重要了。 dockerfile 定义环境 docker-compose 定义服务，运行在隔离的环境中。构建完整的业务单元。 启动命令 docker compose up 安装一般来说，linux 下安装 docker 是不会带 docker compose 的。除非装的是 docker engine ，安装 compose 可以用库也可以用二进制文件 123sudo apt-get updatesudo apt-get install docker-compose-plugindocker compose version #verify that docker-compose is installed correctly 12345678910DOCKER_CONFIG=${DOCKER_CONFIG:-$HOME/.docker}mkdir -p $DOCKER_CONFIG/cli-pluginscurl -SL https://github.com/docker/compose/releases/download/v2.5.0/docker-compose-linux-x86_64 -o $DOCKER_CONFIG/cli-plugins/docker-compose chmod +x $DOCKER_CONFIG/cli-plugins/docker-composesudo chmod +x /usr/local/lib/docker/cli-plugins/docker-composedocker compose version 实例A docker-compose.yml looks like this: 123456789101112131415version: &quot;3.9&quot; # optional since v1.27.0services: web: build: . ports: - &quot;8000:5000&quot; volumes: - .:/code - logvolume01:/var/log links: - redis redis: image: redisvolumes: logvolume01: {} 实操见此，官网文档过于详细，我都不想抄了。 参考Alpine Best practices for writing Dockerfiles docker/compose Overview of Docker Compose","link":"/2021/09/28/docker%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C/"},{"title":"docker项目-calibre书库","text":"电子书有不少，格式也比较杂乱，用 calibre 建立一个本地的管理服务，再用 docker 建立一个网络的书库，未来如果有公网ip之类的，可以实现在线阅读。 安装calibre服务器里安装calibre，linux下，使用二进制安装。 1234567sudo -v &amp;&amp; wget -nv -O- https://download.calibre-ebook.com/linux-installer.sh | sudo sh /dev/stdin可以在末尾加上install_dir=/xxxx 来更改安装目录version=4.xx.x来更改版本号 官网推荐不要使用linux发行版自带的calibre包，版本落后且错误较多。 同时源代码安装也不被推荐。官方的说法是“calibre is a highly complex piece of software with lots of very finicky dependencies. If you install from source, you are on your own. Please do not open bug reports or expect any form of support. You have been warned.” 依赖复杂还没给错误支持。（试了一下确实如此。） 安装完毕后，可以在命令行calibre启动或者点击启动。 官方提示运行前需要 xdg-utils、wget、xz-utils 和 python ≥ 2.6，一般是满足的，但启动时很可能遇上以下错误 1234qt.qpa.plugin: Could not load the Qt platform plugin &quot;xcb&quot; in &quot;&quot; even though it was found.This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem.Available platform plugins are: eglfs, linuxfb, minimal, minimalegl, offscreen, vnc, wayland-egl, wayland, wayland-xcomposite-egl, wayland-xcomposite-glx, xcb. 查阅知，Qt不将xcb与自身绑定，需要额外安装libxcb-xinerama0 1sudo apt-get install libxcb-xinerama0 如果还报错，把libxcb-icccm4，libxcb-image0，libxcb-keysums1，libxcb-render-util0都整上。 创建书库文件夹，要固定一个文件夹专门存放书籍。 安装calibre-web拉取calibre镜像 1docker pull linuxserver/calibre-web 有很多个，linuxserver的一直保持更新的，可以使用。 1234567891011docker run -d \\ --name=calibre-web \\ -e PUID=1000 \\ -e PGID=1000 \\ -e TZ=Asia/Shanghai \\ -e DOCKER_MODS=linuxserver/calibre-web:calibre \\ -p 8083:8083 \\ -v /path/to/data:/config \\ -v /path/to/calibre/library:/books \\ --restart unless-stopped \\ linuxserver/calibre-web 不过配置起来比较一般，所以我还是转向了johngong/calibre-web 12345678910111213docker create \\ --name=calibre-web \\ -p 8083:8083 \\ -p 8080:8080 \\ -v /配置文件位置:/config \\ -v /书库:/library \\ -v /自动添加文件夹:/autoaddbooks \\ -e UID=1000 \\ -e GID=1000 \\ -e CALIBRE_SERVER_USER=用户名 \\ -e CALIBRE_SERVER_PASSWORD=用户密码 \\ --restart unless-stopped \\ johngong/calibre-web:latest 使用起来方便多了。","link":"/2021/11/04/docker%E9%A1%B9%E7%9B%AE-calibre%E4%B9%A6%E5%BA%93/"},{"title":"github-https","text":"使用 https 连接 github。 Error今天 push 不上 github ，很郁闷。胡乱检查了一通。 1234567891011ssh -vT git@github.comOpenSSH_8.2p1 Ubuntu-4ubuntu0.5, OpenSSL 1.1.1f 31 Mar 2020debug1: Reading configuration data /etc/ssh/ssh_configdebug1: /etc/ssh/ssh_config line 19: include /etc/ssh/ssh_config.d/*.conf matched no filesdebug1: /etc/ssh/ssh_config line 21: Applying options for *debug1: Connecting to github.com [::1] port 22.debug1: connect to address ::1 port 22: Connection refuseddebug1: Connecting to github.com [127.0.0.1] port 22.debug1: connect to address 127.0.0.1 port 22: Connection refusedssh: connect to host github.com port 22: Connection refused 123456789101112131415161718192021222324252627nslookup github.comServer: 127.0.0.53Address: 127.0.0.53#53Non-authoritative answer:Name: github.comAddress: 127.0.0.1Name: github.comAddress: ::1nslookup -query=ns github.comServer: 127.0.0.53Address: 127.0.0.53#53Non-authoritative answer:github.com nameserver = ns-520.awsdns-01.net.github.com nameserver = dns1.p08.nsone.net.github.com nameserver = dns3.p08.nsone.net.github.com nameserver = ns-1283.awsdns-32.org.github.com nameserver = dns2.p08.nsone.net.github.com nameserver = ns-421.awsdns-52.com.github.com nameserver = ns-1707.awsdns-21.co.uk.github.com nameserver = dns4.p08.nsone.net.Authoritative answers can be found from: dig 一下 1234567891011121314151617181920212223242526ping github.comPING github.com(ip6-localhost (::1)) 56 data bytes64 字节，来自 ip6-localhost (::1): icmp_seq=1 ttl=64 时间=0.056 毫秒64 字节，来自 ip6-localhost (::1): icmp_seq=2 ttl=64 时间=0.098 毫秒64 字节，来自 ip6-localhost (::1): icmp_seq=3 ttl=64 时间=0.164 毫秒64 字节，来自 ip6-localhost (::1): icmp_seq=4 ttl=64 时间=0.103 毫秒dig github.com; &lt;&lt;&gt;&gt; DiG 9.16.1-Ubuntu &lt;&lt;&gt;&gt; github.com;; global options: +cmd;; Got answer:;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 32912;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1;; OPT PSEUDOSECTION:; EDNS: version: 0, flags:; udp: 65494;; QUESTION SECTION:;github.com. IN A;; ANSWER SECTION:github.com. 275 IN A 127.0.0.1;; Query time: 0 msec;; SERVER: 127.0.0.53#53(127.0.0.53);; WHEN: 五 5月 27 17:49:36 CST 2022;; MSG SIZE rcvd: 55 github 的 a 记录是 127.0.0.1 ，怎么看都不对啊。DNS 污染了。 然后看了一下 hosts ， 没有 github.com 的。我也懒得加了，毕竟总是会被干扰，干脆直接用 https 连接算了。 https看了眼文档，本来以为帐号密码就可以登录的了，结果更新成令牌了。问题不大。 令牌在 github 的个人 setting 的 developer settings 里找到 Personal access tokens ，new 一个就行，有效期和权限视需求随便勾了几个。然后记录下显示的令牌。 连接原来的 ssh 算是废了，代理也不想折腾了。换 https ，官方也推荐。push 不上就多来几次，毕竟走的系统代理。 1234git remote -vgit remote rm origingit remote add origin https://your_repo_adressgit push -u origin main 缓存不能每次都要打帐号密码吧，不能明文存个令牌吧。那就缓存进去好了。 1git config --global credential.helper store hosts当然了，修改host也是可以的 win10hosts 文件在 C:\\WINDOWS\\system32\\drivers\\etc ，管理员打开命令行，notepad hosts ，末尾添加 140.82.113.4 github.com Linuxhosts 文件一般在 /etc/hosts ，sudo 添加即可。 在 win10 测试了修改 hosts 之后 ssh 还是可以正常连接的，，不过我不想用了。","link":"/2022/05/24/github-https/"},{"title":"Hello world","text":"这是对博客运行的各方面的测试页面。 Hello! This is my blog. This is just a test. 图片Hexo Icarus内置Justified Gallery，需要使用如下方式插入图片 1{% img /gallery/dog.jpg &quot;Image title&quot; %} 或者使用HTML的方式 123&lt;div class=&quot;justified-gallery&quot;&gt;&lt;img src=&quot;/gallery/dog.jpg&quot; alt=&quot;puppies&quot; /&gt;&lt;/div&gt; 测试，如何同步文件夹？将根目录改成source 或者使用图床。 1[![RTvTZ8.jpg](https://z3.ax1x.com/2021/07/06/RTvTZ8.jpg)](https://imgtu.com/i/RTvTZ8) #使用图床网站 图床网站 代码12345678910111213141516# Copyright (c) 2021&quot;&quot;&quot;This is just a test for showing code.&quot;&quot;&quot;import osimport sysclass welcome: def __init__(self, date): self.welcome = 1 self.date = date if self.welcome: print('Welcome')def hello(): print(&quot;hello world!&quot;)if __name__ == &quot;__main__&quot;: hello()#---------------------------------------------------------------------------- 无序列表 甲乙丙丁 戊己庚辛 壬 癸 表格 博客 作者 也无风雨也无晴 ivy 图表12345678910111213participant beginparticipant Cparticipant Bparticipant ANote over C: By listing the\\n participants you can\\n change their orderA-&gt;B: horizontal descriptive sentence\\n(normal line)B--&gt;A: dashed lineC-&gt;&gt;D: Open arrowD--&gt;&gt;A: Dashed open arrowC--&gt;&gt;A:Note right of B: note to the\\n right of BNote over A:note over ANote over A,B: Note over both A and B %% Example with selection of syntaxes gantt dateFormat YYYY-MM-DD title Adding GANTT diagram functionality to mermaid section A section Completed task :done, des1, 2014-01-06,2014-01-08 Active task :active, des2, 2014-01-09, 3d Future task : des3, after des2, 5d Future task2 : des4, after des3, 5d section Critical tasks Completed task in the critical line :crit, done, 2014-01-06,24h Implement parser and jison :crit, done, after des1, 2d Create tests for parser :crit, active, 3d Future task in critical line :crit, 5d Create tests for renderer :2d Add to mermaid :1d section Documentation Describe gantt syntax :active, a1, after des1, 3d Add gantt diagram to demo page :after a1 , 20h Add another diagram to demo page :doc1, after a1 , 48h section Last section Describe gantt syntax :after doc1, 3d Add gantt diagram to demo page : 20h Add another diagram to demo page : 48h HTML以下使用HTML代码写成 参考自 [typora官方文档] [github项目js-sequence-diagrams] [js-sequence-diagrams介绍页] [gantt wiki] [mermaid主页] 链接icarus用户指南 公式需要开启配置文件中的plugins的mathjax。使用TEXTEX语法时，请使用$包裹行内公式，$$包裹块状公式。健壮性很低。在Typora内可以显示，但在网页显示时常出错。也可能是语法比较严格，多写几遍咯。 123456789$$\\displaystyle \\frac{1}{\\Bigl(\\sqrt{\\phi \\sqrt{5}}-\\phi\\Bigr) e^{\\frac25 \\pi}} = 1+\\frac{e^{-2\\pi}} {1+\\frac{e^{-4\\pi}} {1+\\frac{e^{-6\\pi}} {1+\\frac{e^{-8\\pi}} {1+\\cdots} } } }$$$$\\max_{G}V(D,G)=E_{z \\sim P_{z}(z)}[logD(G(z))]\\tag{2-1}$$$ \\theta^*= \\arg \\max_{\\theta}\\prod^{m}_{i=1}{P_G(x^i; \\theta)}$$ \\approx \\arg \\max_{\\theta}\\int_x P_{data}(x)log P_G(x; \\theta)dx- \\int_x P_{data} log P_{data}(x)dx$ $$\\displaystyle \\frac{1}{\\Bigl(\\sqrt{\\phi \\sqrt{5}}-\\phi\\Bigr) e^{\\frac25 \\pi}} =1+\\frac{e^{-2\\pi}} {1+\\frac{e^{-4\\pi}} {1+\\frac{e^{-6\\pi}}{1+\\frac{e^{-8\\pi}} {1+\\cdots} } } }$$ $$\\max_{G}V(D,G)=E_{z \\sim P_{z}(z)}[logD(G(z))]\\tag{2-1}$$ $ \\theta^*= \\arg \\max_{\\theta}\\prod^{m}_{i=1}{P_G(x^i; \\theta)}$ $ \\approx \\arg \\max_{\\theta}\\int_x P_{data}(x)log P_G(x; \\theta)dx- \\int_x P_{data} log P_{data}(x)dx$ mathjax/LaTex公式格式查找 Typora公式支持文档 音乐使用Aplayer，一个HTML5音乐播放器，GitHub地址。 12345678910111213141516171819202122232425262728293031{% meting &quot;002j785c33YQHT&quot; &quot;tencent&quot; &quot;song&quot; %} #似乎不行呢{% aplayer &quot;一路向北&quot; &quot;Jay&quot; &quot;https://www.ytmp3.cn/down/69847.mp3&quot; &quot;https://z3.ax1x.com/2021/07/06/RTvTZ8.jpg&quot; &quot;autoplay&quot; %} #autoplay还是算了{% aplayerlist %}{ &quot;narrow&quot;: false, // （可选）播放器袖珍风格 &quot;autoplay&quot;: false, // （可选) 自动播放，移动端浏览器暂时不支持此功能 &quot;mode&quot;: &quot;random&quot;, // （可选）曲目循环类型，有 'random'（随机播放）, 'single' (单曲播放), 'circulation' (循环播放), 'order' (列表播放)， 默认：'circulation' &quot;showlrc&quot;: 3, // （可选）歌词显示配置项，可选项有：1,2,3 &quot;mutex&quot;: false, // （可选）该选项开启时，如果同页面有其他 aplayer 播放，该播放器会暂停 &quot;theme&quot;: &quot;#e6d0b2&quot;, // （可选）播放器风格色彩设置，默认：#b7daff &quot;preload&quot;: &quot;metadata&quot;, // （可选）音乐文件预载入模式，可选项： 'none' 'metadata' 'auto', 默认: 'auto' &quot;listmaxheight&quot;: &quot;513px&quot;, // (可选) 该播放列表的最大长度 &quot;music&quot;: [ { &quot;title&quot;: &quot;可爱女人&quot;, &quot;author&quot;: &quot;Jay&quot;, &quot;url&quot;: &quot;https://www.ytmp3.cn/down/53696.mp3&quot;, &quot;pic&quot;: &quot;https://z3.ax1x.com/2021/07/06/RTvTZ8.jpg&quot;, }, { &quot;title&quot;: &quot;一路向北&quot;, &quot;author&quot;: &quot;Jay&quot;, &quot;url&quot;: &quot;https://www.ytmp3.cn/down/69847.mp3&quot;, &quot;pic&quot;: &quot;https://z3.ax1x.com/2021/07/06/RTvTZ8.jpg&quot;, } ]}{% endaplayerlist %}{% aplayerlist %}{&quot;mode&quot;: &quot;random&quot;,&quot;narrow&quot;:false,&quot;autoplay&quot;: false,&quot;music&quot;: [{&quot;title&quot;: &quot;可爱女人&quot;,&quot;author&quot;: &quot;Jay&quot;,&quot;url&quot;: &quot;https://www.ytmp3.cn/down/53696.mp3&quot;},{&quot;title&quot;: &quot;北&quot;,&quot;author&quot;: &quot;Jay&quot;,&quot;url&quot;: &quot;https://www.ytmp3.cn/down/69847.mp3&quot;}]}{% endaplayerlist %} var ap = new APlayer({ element: document.getElementById(\"aplayer-HJSClKaM\"), narrow: false, autoplay: false, showlrc: false, music: { title: \"一路向北\", author: \"Jay\", url: \"https://www.ytmp3.cn/down/69847.mp3\", pic: \"https://z3.ax1x.com/2021/07/06/RTvTZ8.jpg\", lrc: \"\" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); var ap = new APlayer({ element: document.getElementById(\"aplayer-fkeohVjz\"), narrow: false, autoplay: false, showlrc: false, music: { title: \"Symphony No1 in C Minor\", author: \"Bruckner\", url: \"/music/Berliner Philharmoniker _ 小澤征爾Symphony No_ 1 in C Minor, WAB 101.mp3\", pic: \"/tn/tn_mao.jpg\", lrc: \"\" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); var options = {\"narrow\":false,\"autoplay\":false,\"showlrc\":0,\"mode\":\"random\",\"music\":[{\"title\":\"可爱女人\",\"author\":\"Jay\",\"url\":\"https://www.ytmp3.cn/down/53696.mp3\",\"pic\":\"\"},{\"title\":\"一路向北\",\"author\":\"Jay\",\"url\":\"https://www.ytmp3.cn/down/69847.mp3\",\"pic\":\"\"}]}; options.element = document.getElementById(\"aplayer-yOEHwTxT\"); var ap = new APlayer(options); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 音乐外链网站 123456&lt;audio controls&gt; &lt;source src=&quot;https://www.ytmp3.cn/down/53696.mp3&quot; type=&quot;audio/mpeg&quot;&gt;&lt;/audio&gt;&lt;audio controls autoplay&gt; &lt;source src=&quot;/music/Berliner Philharmoniker _ 小澤征爾Symphony No_ 1 in C Minor, WAB 101.mp3&quot; type=&quot;audio/mpeg&quot;&gt;&lt;/audio&gt; ENDst=>start: Start op_asg=>operation: l=0;h=lenth-1 cond_lh=>condition: loperation: return none op_get=>operation: return g cond_e=>condition: g=a? cond_b=>condition: g>a? op_l=>operation: l=m+1 op_h=>operation: h=m-1 op_g=>operation: g=m e=>end st->op_asg->cond_lh cond_lh(yes)->op_g->cond_e cond_e(no)->cond_b cond_e(yes)->op_get->e cond_b(yes)->op_l->cond_lh cond_b(no)->op_h->cond_lh cond_lh(no)->op_none->e{\"scale\":1,\"line-width\":2,\"line-length\":50,\"text-margin\":10,\"font-size\":12} var code = document.getElementById(\"flowchart-0-code\").value; var options = JSON.parse(decodeURIComponent(document.getElementById(\"flowchart-0-options\").value)); var diagram = flowchart.parse(code); diagram.drawSVG(\"flowchart-0\", options);","link":"/2020/06/18/hello_world/"},{"title":"hexo+icarus博客搭建","text":"使用hexo与icarus搭建博客的过程。 前言​ 使用hexo搭建静态博客，比较简单方便，主题有很多，选择icarus是因为看着简洁大气，结果icarus自3.0后更新为使用jsx，可参考的修改方案不多，于是在github上冲浪了很久，踩了很多坑。 安装Node.js​ 首先下载稳定版，安装完成后命令行输入node -v和npm -v 1234$ node -vv14.17.1$ npm -v6.14.13 ​ 有版本号，安装就没问题了。报错的话重装/清理环境+重装。 添加源​ 没梯子就用阿里镜像加速。 1npm config set registry https://registry.npm.taobao.org 安装Git​ 下载安装就好了，添加git bash到命令菜单。 Github​ 新建项目，项目名字为”github名字.github.io”，README、gitignore、许可全都要。项目内点击Settings，GitHub Pages，点击Choose a theme选择一个主题。完成主页初始化。 Hexo​ 博客目录下右键点击Git Bash Here，输入npm i hexo-cli -g安装完后，输入hexo -v验证是否安装成功。不成功一般是路径问题，找到hexo安装路径，如D:\\node.js\\node_gobal\\node_modules\\hexo-cli\\bin\\，环境变量添加好了之后重新打开 git，一定要重启git，一定要重启git，一定要重启git。 ​ 输入hexo init初始化文件夹，然后输入npm install安装必备的组件。完成后输入hexo g生成静态网页，输入hexo s打开本地服务器，浏览器打开http://localhost:4000/可以进行本地预览。按ctrl+c关闭本地服务器。 连接Github​ 首先右键打开git bash，然后输入下面命令： 12git config --global user.name &quot;GitHub用户名&quot;git config --global user.email &quot;GitHub账号&quot; ​ 然后生成密钥SSH key： 1ssh-keygen -t rsa -C &quot;GitHub账号&quot; ​ 打开github，在头像下面点击settings，再点击SSH and GPG keys，新建一个SSH，名字随便。 ​ git bash中输入 1cat ~/.ssh/id_rsa.pub ​ 将输出的内容复制到框中，点击确定保存。 ​ 输入ssh -T git@github.com 12$ ssh -T git@github.comHi xxxx! You've successfully authenticated, but GitHub does not provide shell access. ​ 打开博客根目录下的_config.yml文件，修改最后一行的配置：（github在老美搞政治正确的时候，把默认分支master改成main了，人都麻了。） 1234deploy: type: git repository: GitHub项目地址 branch: main 编辑文章​ 安装扩展npm i hexo-deployer-git。然后输入hexo new post &quot;文章标题&quot;，新建一篇文章。其中，post代表scaffolds文件夹中的post.md模板，还有draft、page两种模板，都没什么用，可以自定义。在D:\\博客根目录\\source\\_posts的目录，多了一个.md文件，编辑就行。当然也可以写好拉进_posts文件夹。写完后，根目录输入hexo g生成静态网页，输入hexo d上传到github上。 域名有空再弄。要花钱要备案，建议国外域名。买了之后在项目setting的custom domain写上域名。 icarus主题https://github.com/ppoffice/hexo-theme-icarus 12npm install hexo-theme-icarushexo config theme icarus 修改config.yml文件 跟着文档来就行 bug搞完了才写的这博文，很多坑已经忘掉了，没有及时记录。 连接github失败 有可能是vpn问题，可以修改host文件，host可能拒绝访问，用管理员打开power shell在其中输入nodepad编辑。 有可能是项目没连上，能ping通。创建一个同名文件夹，git init然后上传到github，创建第一次连接，之后就可以了。吧？ 一些插件评论插件​ 目前主要有valine、disque、gitalk、畅言等插件，icarus都有自带的实现，只需要在cofig_icarus.yml里修改配置即可。我使用了gitalk。相比其他的插件，虽然gitalk需要登录github才能评论，但是不要求网页备案和域名，使用原始的github.io就可以，而且UI很不错。其他的评论插件其实也需要登录才能开始评价，畅言还有像广告一样的东西，垃圾，valine不需要登录但基于leancloud，需要备案，相似的基于腾讯云的twikoo也是，故弃用。​ 使用gitalk，在github的setting页中的developer settings/OAuth Apps中创建OAuth Apps，其中homepage url与Autorization callback url为博客项目的根目录地址，即https://xx.github.io/，生成后点击生成密钥，并填写到配置文件中。 config_icarus.yml12345678910111213141516comment: type: gitalk client_id: xxxxxxxxxxxxxxxxxxxx client_secret: xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx repo: Some-of-Your-GitHub-Repo owner: you_github_name admin: - you_github_name per_page: 20 # 可选填 distraction_free_mode: false # 可选填 pager_direction: last # 可选填 create_issue_manually: false # 可选填 proxy: # 可选填 flip_move_options: # 可选填 enable_hotkey: true # 可选填 language: zh-CN # 可选填 具体配置查阅gitalk文档，刷新上传博客，评论一次激活。","link":"/2020/06/20/hexo+icarus%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"title":"hexo博客改进记录","text":"原来修改了什么已经忘记了，但是新修改的可以记录一下 固定导航栏在 hexo-theme-icarus\\source\\css\\style.styl 内添加 1234.navbar z-index: 100 position: sticky top: 0 gitalk 评论排列查阅官方文档，在 script 内添加参数，pagerDirection: 'last' 添加新的自定义页面外部链接直接在 icarus 的 config 文件的 navbar 栏添加 xx: 'url' 新页面添加新文件夹，里面新建 index.md，内容和脚本写在里面，并在 icarus 的 config 文件的 navbar 栏添加 xx: 'folder_name' 样式由 hexo 渲染。所以会与博客主题一致。 无样式新页面在页面文件夹直接创建 xx.html ？或者在 index.md 的 front-matter 里添加 layout: false 不同布局的新页面虽然无样式可以创建，但是又得手撸页面，难免有点不爽，不过既然 front-matter 的优先级更高，那就可以在上面写 widget: 将组件置空，那么基础样式将保留。 修改组件、主页面宽度查阅 icarus 的 issue 有介绍，主要就是修改样式。 添加文件改变引用（方便）可以自定义，不过我直接找了个开源分支库，里面有别人写好的，预览了主页感觉可以，直接套上去用了。更新应该也不会刷掉，统一备份 mystyle 就好了应该。步骤如下： 在 hexo-theme-icarus/include/style 下创建 mystyle 文件夹，在内复制粘贴添加一个修改好的 responsive.styl 在 hexo-theme-icarus/source/css/style.styl 内，将 @import '../../include/style/responsive' 修改为 @import '../../include/style/mystyle/responsive' 即可。 直接修改如果想要直接修改 responsive.styl ，在内的 +widescreen() 下修改为如下代码 responsive.styl >folded12345678910111213141516171819202122232425262728293031323334353637383940414243+widescreen() .is-1-column .container, .is-2-column .container max-width: $widescreen - 2 * $gap width: $widescreen - 2 * $gap .is-3-column .container { /* 关闭评论图片 后调节 原94%*/ max-width: 85%; /*screen-widescreen + 2 * extend-width - 2 * gap*/ width: 85%; } max-width: $desktop - 2 * $gap width: $desktop - 2 * $gap .column.is-3-widescreen { flex: none; width: 24%; } .column.is-6-widescreen { width: 52%; } .column.is-4-widescreen { flex: none; width: 24%; } .column.is-8-widescreen { width: 76%; } .column.is-9-widescreen { width: 76%; } //screen-widescreen + 2 * extend-width - 2 * gap .navbar &gt; .container .navbar-brand, .container &gt; .navbar .navbar-brand { margin-left: 0%; } .navbar &gt; .container .navbar-menu, .container &gt; .navbar .navbar-menu { margin-right: 0.5%; } .level-end { margin-right: -1.5%; } 其他方法引自Carol的 hexo-icarus 博客： 修改側欄及文章區塊所佔網格比例 放寬內容區塊(側欄加文章區塊)後，再來就是修改側欄以及文章區塊所佔的網格比，讓側欄變窄，中間文章區塊變寬 預設側欄(兩側)所佔的網格比，可在 themes/icarus/layout/common/widgets.jsx 檔案中看到 修改文章區塊與側欄區塊比例 接下來我們要放寬文章區塊，減少側欄區塊寬度 在 themes/icarus/layout/common/widgets.jsx，修改側欄(兩側)所佔的網格比 在 themes/icarus/layout/layout.jsx，修改文章區塊所佔的網格比 归档页添加年份生肖逛 icarus 的 issue 发现好玩的，试着加到博客里，可惜的是没有插件式的套件。 原 issue 提出的修改方法： 下载字体：chinese-zodiac.zip (23.2KB)，下载后将解压的三个字体文件全部放在 icarus/source/fonts 下 添加样式: 在 icarus/style/timeline.styl 中加入，为避免修改带来的bug，我在 mystyle 复制新的 timeline.styl 并添加下面的代码，在 style.styl 修改引用。 timeline.styl >folded123456789101112131415161718192021222324252627282930313233343536.chinese-zodiac { float: right;}@font-face { font-family: 'chinese-zodiac'; font-display: swap; src: url('/fonts/chinese-zodiac.eot'); src: url('/fonts/chinese-zodiac.eot') format('embedded-opentype'), url('/fonts/chinese-zodiac.woff2') format('woff2'), url('/fonts/chinese-zodiac.woff') format('woff'); font-weight: normal; font-style: normal;}.symbolic-animals { color: #3273DC; display: inline-block; font: normal normal normal 14px/1 chinese-zodiac; font-size: x-large; text-rendering: auto; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale;}.icon-dragon:before { content: '\\e806'; }.icon-tiger:before { content: '\\e809'; }.icon-pig:before { content: '\\e810'; }.icon-horse:before { content: '\\e813'; }.icon-rat:before { content: '\\e816'; }.icon-goat:before { content: '\\e818'; }.icon-snake:before { content: '\\e820'; }.icon-ox:before { content: '\\e822'; }.icon-dog:before { content: '\\e825'; }.icon-rabbit:before { content: '\\e826'; }.icon-monkey:before { content: '\\e829'; }.icon-rooster:before { content: '\\e82f'; } 修改 hexo-theme-icarus\\layout\\archive.jsx ：将 renderArticleList 函数修改为 archive.jsx >folded1234567891011121314151617181920212223242526272829function renderArticleList(posts, year, month = null) { const time = moment([page.year, page.month ? page.month - 1 : null].filter(i =&gt; i !== null)); const zodiac = (() =&gt; { switch (year % 12) { case 0: return 'symbolic-animals icon-monkey'; case 1: return 'symbolic-animals icon-rooster'; case 2: return 'symbolic-animals icon-dog'; case 3: return 'symbolic-animals icon-pig'; case 4: return 'symbolic-animals icon-rat'; case 5: return 'symbolic-animals icon-ox'; case 6: return 'symbolic-animals icon-tiger'; case 7: return 'symbolic-animals icon-rabbit'; case 8: return 'symbolic-animals icon-dragon'; case 9: return 'symbolic-animals icon-snake'; case 10: return 'symbolic-animals icon-horse'; case 11: return 'symbolic-animals icon-goat'; default: return 'symbolic-animals icon-ox'; } })(); return &lt;div class=&quot;card&quot;&gt; &lt;div class=&quot;card-content&quot;&gt; &lt;h3 class=&quot;tag&quot;}&gt;{month === null ? year : time.locale(language).format('MMMM YYYY')}&lt;/h3&gt; &lt;div class=&quot;chinese-zodiac&quot;&gt; &lt;i class={zodiac}&gt; &lt;/i&gt; &lt;/div&gt;} 修改颜色这份修改的源码将颜色设为红色，有点不搭。将颜色改回原来的 #3273DC 。上面第一份代码搜索 color 修改。 夜间模式的适配添加了这玩意后，夜间模式下，样式也得适配添加。在 night.styl 的 time line 内添加 .symbolic-animals ，如下： 123456//time line.timeline xxx xxx.symbolic-animals color: #C0C0C0 颜色选择合适的就行。 修改部署后样式的同步经常改了之后本地预览没问题，hexo d 之后没有变化，文章倒是有更新，查来查去，shift + f5 强制刷新页面，清理缓存一般就可以了。 多端同步与客制化位置由于 git push 到仓库时，.gitignore 将 node_modules/hexo-theme-icarus 加入不上传列表，那么对应的修改就没有同步，解决的办法就是，将这个文件夹内容全部复制，到博客目录下的 themes 内创建 icarus 目录并粘贴。 这样，hexo 就会以 themes/icarus 内的设置对页面配置，算是客制化设定（其实一开始就应该做这一步，然后在 themes/icarus 内进行客制化主题修改的）。 则同步上传时，会将该文件夹同步。 参考gitalkgitalk-github文档：https://github.com/gitalk/gitalk 页面的布局icarus用户指南：https://ppoffice.github.io/hexo-theme-icarus/Configuration/icarus-user-guide-configuring-the-theme/#Configuration-Files-and-Priority 宽度修改Hexo - Icarus 主題 - 內容區塊寬度：https://carol-yang09.github.io/2020/11/22/hexo-icarus-themes-content-width/ 可否增加内容栏自定义宽度功能 #434：https://github.com/ppoffice/hexo-theme-icarus/issues/434 hexo-theme-amazing-responsive.styl：https://github.com/removeif/hexo-theme-amazing/blob/7fea32fa88ef79b3ca0c697ed55ee3213f72bb2b/include/style/mystyle/responsive.styl 归档页添加年份生肖在归档界面加入与年份对应的12生肖小图标 #776：https://github.com/ppoffice/hexo-theme-icarus/issues/776","link":"/2021/10/09/hexo%E5%8D%9A%E5%AE%A2%E6%94%B9%E8%BF%9B%E8%AE%B0%E5%BD%95/"},{"title":"Javascript基础","text":"Javascript基础的学习记录。 JS简介JavaScript基础分为三个部分： ECMAScript：JavaScript 的语法标准。包括变量、表达式、运算符、函数、if语句、for语句等。 DOM：Document Object Model（文档对象模型），操作页面上的元素的API。比如让盒子移动、变色、改变大小、轮播图等等。 BOM：Browser Object Model（浏览器对象模型），操作浏览器部分功能的API。通过BOM可以操作浏览器窗口，比如弹框、控制浏览器跳转、获取浏览器分辨率等等。 通俗理解就是：ECMAScript 是 JS 的语法；DOM 和 BOM 浏览器运行环境为 JS提供的API。 引入JS代码方式大致有三种，行内、嵌入以及外部引入。一般用外部引入。 行内行内式1&lt;input type=&quot;button&quot; value=&quot;点我点我&quot; onclick=&quot;alert('Hello')&quot; /&gt; 可以将单行或少量 JS 代码写在HTML标签的事件属性中（以 on 开头的属性），比如放在上面的 onclick点击事件中。可读性差。容易出错，不好维护。 关于代码中的「引号」，在HTML标签中，我们推荐使用双引号, JS 中我们推荐使用单引号。 嵌入我们可以在html 页面的 &lt;body&gt; 标签里放入&lt;script type=”text/javascript”&gt;&lt;/script&gt;标签对，并在&lt;script&gt;里书写JavaScript 代码。练习测试的时候可以用一用。 外部引入编写另外js文件，在HTML中引用。 1234567891011&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 引入外部的 js 文件 --&gt; &lt;script src=&quot;tool.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 上面这段代码，依然是放到body标签里，可以和内嵌的js代码并列。另外，引用外部 JS文件的 script 标签中间不可以再写代码。 Javascript语法语法总览 JavaScript对换行、缩进、空格不敏感。每一条语句以分号结尾。 所有的符号，都是英语的。比如括号、引号、分号。 严格区分大小写。 注释 HTML、CSS、JavaScript三者的注释格式。 HTML 的注释 1&lt;!-- 我是注释 --&gt; CSS的注释 123456&lt;style type=&quot;text/css&quot;&gt; /* 我是注释 */&lt;/style&gt; 注意：CSS只有/* */这种注释，没有//这种注释。而且注释要写在&lt;style&gt;标签里面才行。 JavaScript 的注释 单行注释： 1// 我是注释 多行注释： 1234/* 多行注释1 多行注释2*/ 输入输出alert(&quot;&quot;)语句，弹出“警告框”。 console.log(&quot;&quot;)表示在控制台中输出 prompt()就是专门用来弹出能够让用户输入的对话框。用得少，测试的时候偶尔会用。 字面量包括数字、字符串、布尔值。“字面量”即常量，是固定值，不可改变。看见什么，它就是什么。 12345alert(369)console.log('886');if (true) {} 一般不直接使用，还是用变量好。 变量在ES6语法之前，统一使用var关键字来声明一个变量。比如： 1var name; // 声明一个名为 name 的变量 在ES6语法及之后，可以使用 const、let关键字来声明一个变量 123const name; // 定义一个常量let age; 如果你想定义一个常量，就用 const；如果你想定义一个变量，就用 let。 变量的声明和赋值，写在一起就行。复赋值后，它原有的值就会被覆盖，变量值将以最后一次赋的值为准。 声明多个变量时，只需要写一个 var， 多个变量名之间用英文逗号隔开。 为什么用 let ？变量升级问题。 标识符：在JS中所有的可以由我们自主命名的都可以称之为标识符。 例如：变量名、函数名、属性名、参数名都是属于标识符。通俗来讲，标识符就是我们写代码时为它们起的名字。 关键字：是指 JS 本身已经使用了的单词，我们不能再用它们充当变量、函数名等标识符。 JS 中的关键字如下： 关键字 >folded1234567891011break、continue、case、default、if、else、switch、for、in、do、while、try、catch、finally、throw、var、void、function、return、new、this、typeof、instanceof、delete、with、true、false、null、undefined 保留字：实际上就是预留的“关键字”。意思是现在虽然还不是关键字，但是未来可能会成为关键字，同样不能使用它们当充当变量名、函数名等标识符。 JS 中的保留字如下： 保留字 >folded123456789abstract、boolean、byte、char、class、const、debugger、double、enum、export、extends、final、float、gotoimplements、import、int、interface、long、native、package、private、protected、public、short、static、super、synchronized、throws、transient、volatile 数据类型avaScript 是一种「弱类型语言」，或者说是一种「动态语言」，这意味着不需要提前声明变量的类型，在程序运行过程中，类型会自动被确定。JS 的变量数据类型，是在程序运行的过程中，根据等号右边的值来确定的。而且，变量的数据类型是可以变化的。 JS中一共有六种数据类型 基本数据类型（值类型）：String 字符串、Number 数值、Boolean 布尔值、Null 空值、Undefined 未定义。 引用数据类型（引用类型）：Object 对象。 内置对象 Function、Array、Date、RegExp、Error等都是属于 Object 类型。也就是说，除了那五种基本数据类型之外，其他的，都称之为 Object类型。 数据类型区别： 基本数据类型：参数赋值的时候，传数值。保存在栈内存。 引用数据类型：参数赋值的时候，传地址（修改的同一片内存空间）。保存在堆内存。 字符串字符串的不可变性 字符串里面的值不可被改变。虽然看上去可以改变内容，但其实是地址变了，内存中新开辟了一个内存空间。 代码举例： 123var str = 'hello';str = 'bye'; 比如上面的代码，当重新给变量 str 赋值时，常量hello不会被修改，依然保存在内存中；str 会改为指向bye。 模板字符串（模板字面量）ES6中引入了模板字符串，让我们省去了字符串拼接的烦恼。 在模板字符串中插入变量以前，让字符串进行拼接的时候，是这样做的：（传统写法的字符串拼接） 123var name = 'smyhvae';var age = '26';console.log('name:' + name + ',age:' + age); //传统写法 这种写法，比较繁琐，而且容易出错。 现在，有了 ES6 语法，字符串拼接可以这样写： 123456var name = 'qianguyihao';var age = '26';console.log('我是' + name + ',age:' + age); //传统写法console.log(`我是${name},age:${age}`); //ES6 写法。注意语法格式 注意，上方代码中，倒数第二行用的符号是单引号，最后一行用的符号是反引号（在 tab 键的上方）。 在模板字符串中插入表达式以前，在字符串中插入表达式的写法必须是这样的： 123const a = 5;const b = 10;console.log('this is ' + (a + b) + ' and\\nnot ' + (2 * a + b) + '.'); 现在，通过模板字符串，我们可以使用一种更优雅的方式来表示： 123456const a = 5;const b = 10;// 下面这行代码，故意做了换行。console.log(`this is ${a + b} andnot ${2 * a + b}.`); 打印结果： 12this is 15 andnot 20. 模板字符串中可以换行因为模板字符串支持换行，所以可以让代码写得非常美观。 代码举例： >folded1234567891011121314const result = { name: 'ivy', age: 18, sex: '男',};// 模板字符串支持换行const html = `&lt;div&gt; &lt;span&gt;${result.name}&lt;/span&gt; &lt;span&gt;${result.age}&lt;/span&gt; &lt;span&gt;${result.sex}&lt;/span&gt;&lt;/div&gt;`;console.log(html); // 打印结果也会换行 模板字符串中可以调用函数模板字符串中可以调用函数。字符串中调用函数的位置，将会显示函数执行后的返回值。 举例： 12345function getName() { return 'ivy';}console.log(`www.${getName()}.com`); // 打印结果：www.ivy.com 模板字符串支持嵌套使用1234567891011const nameList = ['ivy1', 'ivy2', 'ivy3'];function myTemplate() { // join('') 的意思是，把数组里的内容合并成一个字符串 return `&lt;ul&gt; ${nameList .map((item) =&gt; `&lt;li&gt;${item}&lt;/li&gt;`) .join('')} &lt;/ul&gt;`;}document.body.innerHTML = myTemplate() 数组数值在JS中所有的数值都是 Number 类型，包括整数和浮点数。 NaN：是一个特殊的数字，表示Not a Number，非数值。比如： 123console.log(&quot;abc&quot; / 18); //结果是NaNconsole.log(&quot;abc&quot; * &quot;abcd&quot;); //按理说，字符串相乘是没有结果的，但如果你非要让JS去算，它就一定会给你一个结果。结果是NaN 注意：typeof NaN的返回结果是 number。 Undefined和任何数值计算的结果为 NaN。NaN 与任何值都不相等，包括 NaN 本身。 连字符和加号的区别键盘上的+可能是连字符，也可能是数字的加号。如下： 123console.log(&quot;我&quot; + &quot;爱&quot; + &quot;你&quot;); //连字符，把三个独立的汉字，连接在一起了console.log(&quot;我+爱+你&quot;); //原样输出console.log(1+2+3); //输出6 输出： 123我爱你我+爱+你6 总结：如果加号两边都是 Number 类型，此时是数字相加。否则，就是连字符（用来连接字符串）。 举例1： 123var a = &quot;1&quot;;var b = 2;console.log(a + b); 控制台输出： 112 举例2： 123var a = 1;var b = 2;console.log(&quot;a&quot; + b); //&quot;a&quot;就不是变量了！所以就是&quot;a&quot;+2 输出a2 控制台输出： 1a2 在变量中加入字符串进行拼接，可以被同化为字符串。 隐式转换我们知道，&quot;2&quot;+1得到的结果其实是字符串，但是&quot;2&quot;-1得到的结果却是数值1，这是因为计算机自动帮我们进行了“隐式转换”。 也就是说，-、*、/、%这几个符号会自动进行隐式转换。例如： 12var a = &quot;4&quot; + 3 - 6;console.log(a); 输出结果： 137 虽然程序可以对-、*、/、`%``这几个符号自动进行“隐式转换”；但作为程序员，我们最好自己完成转换，方便程序的可读性。 例： 1234567 //a bvar a = &quot;1&quot;;var b = 2;a = b + a; //&quot;21&quot; 2b = b + a; //&quot;21&quot; &quot;221&quot;console.log(a); //21console.log(b) //221 效果： 1221221 例： 123var a = &quot;3&quot;;var b = 2;console.log(a-b); 效果：（注意，字符串 - 数值 = 数值） 11 Nullnull 专门用来定义一个空对象（例如：let a = null）。 如果你想定义一个变量用来保存引用类型，但是还没想好放什么内容，这个时候，可以在初始化时将其设置为 null。 比如： 12let myObj = null;cosole.log(typeof myObj); // 打印结果：object 补充： Null 类型的值只有一个，就是 null。比如 let a = null。 使用 typeof 检查一个 null 值时，会返回 object。 undefinedcase1：变量已声明，未赋值时声明了一个变量，但没有赋值，此时它的值就是 undefined。举例： 123let name;console.log(name); // 打印结果：undefinedconsole.log(typeof name); // 打印结果：undefined 补充： Undefined 类型的值只有一个，就是 undefind。比如 let a = undefined。 使用 typeof 检查一个 undefined 值时，会返回 undefined。 case2：变量未声明（未定义）时如果你从未声明一个变量，就去使用它，则会报错（这个大家都知道）；此时，如果用 typeof 检查这个变量时，会返回 undefined。举例： 12console.log(typeof a); // undefinedconsole.log(a); // 打印结果：Uncaught ReferenceError: a is not defined case3：函数无返回值时如果一个函数没有返回值，那么，这个函数的返回值就是 undefined。 或者，也可以这样理解：在定义一个函数时，如果末尾没有 return 语句，那么，其实就是 return undefined。 举例： 123function foo() {}console.log(foo()); // 打印结果：undefined case4：调用函数时，未传参调用函数时，如果没有传参，那么，这个参数的值就是 undefined。 举例： 12345function foo(name) { console.log(name);}foo(); // 调用函数时，未传参。执行函数后的打印结果：undefined 实际开发中，如果调用函数时没有传参，我们可以给形参设置一个默认值： 12345function foo(name) { name = name || 'qianguyihao';}foo(); ES6 之后，上方代码也可以这样写： 123function foo(name = 'qianguyihao') {}foo(); null 和 undefined 有很大的相似性。看看 null == undefined 的结果为 true 也更加能说明这点。 但是 null === undefined 的结果是 false。它们虽然相似，但还是有区别的，其中一个区别是，和数字运算时： 10 + null 结果为 10。 10 + undefined 结果为 NaN。 规律总结： 任何数据类型和 undefined 运算都是 NaN; 任何值和 null 运算，null 可看做 0 运算。 数据类型转换运算符比较算符===，！==等。逻辑算符&amp;&amp;，||，！等。 控制语句if、switch、while、for。懂的都懂，典中典了。 函数与方法函数是对象方法的一部分，不过不重要，会用就行。 函数使用function functionName(){}定义，使用functionName()调用。匿名函数无函数名，一般与事件处理程序一并使用，或分配到变量，使用varName()调用，但这样不如直接命名一个函数，所以这并不常见。 事件对于事件处理器，可以使用匿名函数、有名字的函数赋值到事件处理参数和DOM，如下： btn.onclick = function(){} function eventReact(){} btn.onclick = eventReact() btn.addEventListener('click',eventReact) 其中DOM的事件处理函数需要两个参数，事件名称和处理函数，当然，同第一项写成匿名函数也可以 btn.addEventListener('click', function(){}) DOM的方式可以清除废弃的事件处理器，给监听器注册多个处理器等。 事件的冒泡与捕获这是两个顺序相反的过程，事件捕获时，自祖先元素开始查找。冒泡时，自子元素开始向上，处理事件事，在冒泡阶段注册程序，如果不阻止冒泡链的扩大，则会在所有的父元素同事件执行。但也可以利用冒泡，将重复的子元素事件响应委托到一个父元素中。","link":"/2019/10/09/javascript%E5%9F%BA%E7%A1%80/"},{"title":"nonebot-QQ智障机器人（部署）","text":"NoneBot ，利用 OneBot 实现的 Python 异步机器人框架。现在的版本已经是 v2了，要求 Python &gt;= 3.7.3 ，通过插件化的形式，将消息分发到命令处理器和自然语言处理器，完成具体功能，拓展性挺强的。整一个玩玩，顺手写一个傻瓜式笔记记录。 开始开始之前，确保 python 在3.7.3 以上，后续安装的是 v2 版本，所以先将原来的卸载了 1pip uninstall nonebot 其他需要补充的前提 了解 python 异步机制 了解 PEP 484，NoneBot2 用此实现类型注解 改进编辑器 编辑器我使用 VS code ，推荐也是使用这个。使用 pylance Language Server 并启用 Type Checking 的 basic 模式以达到最佳开发体验。 VS code 配置插件 pylance、jupyter 配置虚拟环境一般来说 venv 一个就行了，但是既然都开了大坑，干脆就把 Anaconda 也装上。 在 Ubuntu 安装 Anaconda ，首先在官网下载安装包，是 .sh 后缀的，依据文档进行校验安装。 1234567891011121314151617181920#检验完整性sha256sum /path/filenamebash /path/filename #一般为：~/Downloads/Anaconda3-2020.02-Linux-x86_64.sh#重启终端，检查安装conda version#关闭终端默认自启的conda base环境conda config --show | grep auto_activate_baseconda config --set auto_activate_base False#进入basesource ~/anaconda3/bin/activate root#退出，关闭终端重启或命令conda deactivate#查看环境conda env listconda info -e#查看包列表conda list#启动anacondasource ~/anaconda3/bin/activate rootanaconda-navigator 然后创建虚拟环境nonebot。 避免风控一般来说，QQ机器人被tx风控是正常的事。据说不要经常群发、链接、图片。还有建议不要太嘲讽，把机器人部署到腾讯云里。反正我反手把QQ塞到挂号平台开一个月刷刷活跃，服务器也是自己组的，部署运行几天看看。 安装一般还是装个脚手架比较方便。 1234pip install nb-cli# 纯净安装无脚手架pip install nonebot2poetry add nonebot2 驱动器安装文档说默认内置 fastapi 服务端，一般来说是不够的。 123456# 查看驱动器列表nb driver list# 安装nb driver install &lt;driver&gt;# or use pip to installpip install &lt;driver&gt; 或者去NB2商店复制安装驱动器。 协议适配器同样地，NB2商店也可以直接装。 123nb adapter listnb adapter install &lt;adapter&gt;pip install &lt;adapter&gt; 第三方插件同样， 123nb plugin listnb plugin install &lt;plugin&gt;pip install &lt;plugin&gt; go-cqhttp下载最新的 Release，解压并初始化（运行go-cqhttp），开启自动配置，以 ubuntu 为例 解压目录下（建议放到机器人目录），打开终端，./go-cqhttp 执行命令，选择“反向 Websocket 通信”，等待初始化 config.yml 。 配置 config.yml ，更改帐号，不需要填密码，设置反向 ws universal 的地址。为：ws://127.0.0.1:port/onebot/v11/ws 文件说明：device.json 保存设备信息，务必不要删除，go-cqhttp：用于启动程序，session.token：QQ登录服务器后产生的token，后续不用再次扫码。如果以后登录不上，删除后重新扫码登录。 创建项目到目标目录下，激活虚拟环境 12conda info -econda activate &lt;env_name&gt; 创建项目 12345678910nb creat# ValueError: Unknown scheme for proxy URL URL('socks ...# 有可能是v2ray的代理设置导致的，先关闭，清空代理，项目创建完再重启v2rayenv | grep -i proxyunset ALL_PROXYunset all_proxy# 正常进入就是设置项目名称等参数的界面，选择插件存放位置，然后选择echo，选择onebot v11完成创建#完成后进入项目目录，如awesome-botnb run#一切正常即可退出。 之后的启动在目录下，不要遗漏激活虚拟环境 12345nb run# orpython bot.py# activateconda activate nonebot 目录结构 bot/plugins 或 src/plugins: 用于存放编写的 bot 插件 .env、.env.dev、.env.prod: 各环境配置文件 bot.py: bot 入口文件 pyproject.toml: 项目插件配置文件 Dockerfile、docker-compose.yml: Docker 镜像配置文件 配置.env 文件内设置使用 dev 或 prod 的配置，随便哪个都行。 对应的配置文件如下 123456HOST=127.0.0.1 #配置监听的IP/主机PORT=xxxxx #同GOCQ的config内的端口，监听的端口SUPERUSERS=[] #超级用户NICKNAME=[&quot;&quot;, &quot;&quot;] #昵称COMMAND_START=[&quot;/&quot;] #命令起始符COMMAND_SEP=[&quot;.&quot;] #命令分隔符 初次调试 环境配置完成后，命令行执行 nb run 或者在 IDE 内以非调试模式运行，但不建议。 nonebot 开启后，到gocq目录下执行 ./go-cqhttp 以打开 gocq 。 一般来说上述两步执行完就完成 hello world 了。打开QQ对机器人发送信息 /echo hello world ，有正常回复就算完成了初始化搭建。 参考GitHub NoneBot GitHub go-cqhttp NoneBot v2 Docs go-cqhttp quick_start 基于go-cqhttp和NoneBot2的QQ机器人实现 NB2商店 well404的博客","link":"/2022/01/04/nonebot-QQ%E6%99%BA%E9%9A%9C%E6%9C%BA%E5%99%A8%E4%BA%BA%EF%BC%88%E4%B8%80%EF%BC%89/"},{"title":"nonebot-QQ智障机器人（插件与docker）","text":"虽然部署完成了，但还需要编写并添加插件补充机器人的功能。尝试 docker 部署，自启等。 Docker部署因为启动一次 nonebot 和 go-cqhttp 就需要占用一个终端窗口，后台启动又比较麻烦，而且每次服务器自启动都要手动启动一次服务，比较麻烦，与其实现一个后台运行和自启脚本，不如直接扔到 docker 里。（然后发现更麻烦了） docker file12345678910111213141516171819202122232425FROM python:3.10 as requirements-stageWORKDIR /tmpCOPY ./pyproject.toml ./poetry.lock* /tmp/RUN curl -sSL https://install.python-poetry.org -o install-poetry.pyRUN python install-poetry.py --yesENV PATH=&quot;${PATH}:/root/.local/bin&quot;RUN poetry export -f requirements.txt --output requirements.txt --without-hashesFROM tiangolo/uvicorn-gunicorn-fastapi:python3.9WORKDIR /appCOPY --from=requirements-stage /tmp/requirements.txt /app/requirements.txtRUN pip install --no-cache-dir --upgrade -r requirements.txtRUN rm requirements.txtCOPY ./ /app/ docker-compose123456789101112131415161718192021222324252627282930version: &quot;3&quot;services: gocqhttp: image: pcrbot/gocqhttp:latest container_name: go-cqhttp volumes: - ./gocqhttp:/data # 用于保存 gocqhttp 相关文件，请复制 config.yml 等文件到此 tty: true stdin_open: true environment: - TZ=Asia/Shanghai depends_on: - beta-bot beta-bot: build: ./beta-bot # 构建nonebot执行环境 container_name: nonebot-beta ports: - &quot;8055:8055&quot; # 映射端口到宿主机 宿主机端口:容器端口 env_file: - &quot;.env.prod&quot; # fastapi 使用的环境变量文件 environment: - ENVIRONMENT=prod # 配置 nonebot 运行环境，此项会被 .env 文件覆盖 - MAX_WORKERS=1 # 如果你有多个QQ，且存在 self_id 指定，多个 worker 会导致无法找到其他 websocket 连接 - TZ=Asia/Shanghainetworks: default: name: workspace-default 手动配置docker使用 python3.9:lastest 镜像。 1234pip install nb clinb createnb install plugin nonebot_plugin_gocqhttpnb run 12345678910111213# 设置自启vim /root/start.sh# start.shecho &quot;startup run...&quot; &gt;&gt;/root/start.lognb run# 授权chmod +x /root/start.sh# 添加到自启vim /root/.bashrc# 修改内容if [ -f /root/start.sh ]; then ./root/start.shfi 1234docker container ls # get container iddocker psdocker diff iddocker commit id yourname/imagename:tag docker总结用 docker 搭建其实勉勉强强，确实能跑起来，但自启、插件添加都非常不方便，因为不熟悉，调试也很麻烦，还是踢回本地挂着。 其中遇到的 bug ： 代理报错：unset！！！ 容器互通失败：不要在 compose 里搭建，自己再建一个手动连（这有什么区别？） 自启时插件加载失败：不要自启 webUI 端口无法映射：反正也没用，爷不要了 启动日志丢失：重定向一个新的（到底有什么区别？？？） 注释 nonebot.load_from_toml(&quot;pyproject.toml&quot;) 后，资源加载失败，不注释插件重复下载加载：不要自启 数据持久化卷挂载：COPY一份先。 可以说什么 bug 都踩了个遍，官网文档关于 docker 的还什么都没有，一个个解决完我真的绷不住了。最容易成功的就是手动搭一个然后用插件化的 gocqhttp 完成首次登录，之后的每次登录都手动启动（.sh 自启会报错，手动同样的命令nonebot不会报资源加载失败错误，绷不住了），实在是太不自动化了，很不优雅。 添加插件如果不是自己编写的，在商店搜索并复制安装命令，或者 1234nb plugin listnb install plugin &lt;plugin_name&gt; nb plugin install #交互式 配置 在 bot.py 的主函数前添加声明，nonebot.load_plugin(&quot;plugin_name&quot;) 在全局配置文件 .env.prod 或 .env.dev 中添加配置项以管理插件功能，具体项见插件 GitHub 页的自述。 插件列表 nonebot_plugin_status nonebot_plugin_gocqhttp（会出bug，会暴露端口，不用了。） 本地后台自启shell 脚本或者 systemd ，这里用个.sh脚本算了。写完记得赋权 chmod +x start.sh 启动 nb/bin/bash startnb.sh 123#!/bin/bashsource /home/usrname/anaconda3/bin/activate env_namenohup nb run &gt;nbrun.log 2&gt;&amp;1 &amp; 因为 ubuntu 太挫了，默认 shell 解释器是 dash ，所以要指定为 bash ，同时用 bash 执行。 直接 conda activate env_name 写在 .sh 里一般是不行的，会报 CommandNotFoundError：shell not been properly configured to use xx 的错。 如果不改解释器，会报 source: not found 。 启动 gocqhttp这个简单。 1nohup ./go-cqhttp &gt;gocqrun.log 2&gt;&amp;1 &amp; 启动加到开机自启里就行。 1cd ~/ &amp;&amp; /bin/bash ./starttheta.sh &amp;&amp; cd ~/go-cqhttp &amp;&amp; ./startgocq.sh 另外写个一键关闭的脚本。 12345678910111213141516171819202122#!/bin/shpid=$(ps -ef | grep go-cqhttp | grep -v grep | awk '{print $2}')if [ $pid ]then echo &quot;PID: $pid&quot; kill $pid echo &quot;Go-cq has been shutdown!&quot;else echo &quot;Process go-cq doesn't exist!&quot;fipidbot=$(ps -ef | grep nbtehta | grep -v grep | awk '{print $2}')if [ $pidbot ]then echo &quot;PID: $pidbot&quot; kill $pidbot echo &quot;Nonebot has been shutdown!Bye!&quot;else echo &quot;Process nbtheta doesn't exist!&quot;fiecho &quot;\\n (__)\\n (oo)\\n /------\\/ \\n / | || \\n* /\\---/\\ \\n ~~ ~~\\n 超级牛力！&quot; 之类的。 参考koyeb-nb2 Dockerfile reference Compose specification docker容器内服务开机自启动实现方案（以ssh服务为例） nonebot.plugin 在shell脚本中激活conda虚拟环境","link":"/2022/01/05/nonebot-QQ%E6%99%BA%E9%9A%9C%E6%9C%BA%E5%99%A8%E4%BA%BA%EF%BC%88%E6%8F%92%E4%BB%B6%E4%B8%8Edocker%EF%BC%89/"},{"title":"","text":"python的基础镜像，buster、jessie、stretch、bullseye 这三个代表不同的 bebian 版本号（Python镜像以 Debian 为基础） buster —— debian 10stretch —— debian 9jessie —— debian 8 bullseye、bookworm —— 正在开发但尚未稳定版本 slim slim 表示最小安装包，仅包含需要运行指定容器的特定工具集注：在使用 slim 版本时，一定要进行完全测试，若功能无法满足要求就要更换完整版镜像 Alphine Alphine 是专门为容器构建的操作系统，比其他的操作系统更小，但是其上会缺少很多软件包并且使用的 glibc 等都是阉割版 windows server 适配 windows 和 windows server 的容器","link":"/2023/01/12/python%E7%9A%84%E5%9F%BA%E7%A1%80%E9%95%9C%E5%83%8F/"},{"title":"rime的Linux配置","text":"rime 是一个开源的跨平台输入法引擎，功能和可定制性非常强大，需要通过修改配置文件来设置，有一定门槛。 在 windows 下是小狼毫， MacOS 下是鼠须管，在 Linux 下，根据挂接输入法框架的不同，分为 ibus-rime 和 fcitx-rime。选用对应的就好。定制化方案是通过配置文件来修改的。 安装下以 debian 系的 ibus 安装为例。 123sudo apt-get install ibus-rime# 其他sudo apt-get install fcitx-rime 安装完毕后，在设置的语言-输入源中添加 rime 输入源。 为了管理输入方案配置，安装管理工具 1curl -fsSL https://raw.githubusercontent.com/rime/plum/master/rime-install | bash 安装双拼 1sudo apt-get install librime-data-double-pinyin 配置配置文件的加载流程： ibus 启动 rime 启动 开始去 .config/ibus/rime 或 .config/fcitx/rime 下去查看 default.yaml是否存在，存在就使用这个文件进行配置 如果上边没有找到 default.yaml 则去 /usr/share/rime-data 中取回所有默认配置 然后查找是否有自定义配置，如果有，就在默认的基础上打补丁，使自定义配置添加入 default.yaml 中 启动完成，配置生效 其中，.config/ibus/rime 或 .config/fcitx/rime 会有几个文件比较特殊这里说明下， default.yaml ：这里最后的部署整合到一起的配置文件，不要在这里写配置 default.custom.yaml ：在这个文件中，我们可以创建自定义的全局配置，需要自己创建 installation.yaml ：安装时自动创建的配置文件 输入方案名.schema.yaml：输入方案的默认配置文件 输入方案名.custom.yaml ：仅对指定输入方案的配置进行修改的配置文件 其余的均为输入方案生成的，可以不管 symbols.yaml ：这个文件是符号相关的设置 双拼添加配置文件，路径：/home/user/.config/ibus/rime ，添加 defaule.custom.yaml 内容： 1234patch: &quot;menu/page_size&quot;: 6 schema_list: - {schema: double_pinyin_flypy} 简体添加 double_pinyin_flypy.custom.yaml ，配置使得简体优先。 123456789101112patch: switches: - name: ascii_mode reset: 0 states: [&quot;中文&quot;, &quot;西文&quot;] - name: full_shape states: [&quot;半角&quot;, &quot;全角&quot;] - name: simplification reset: 1 states: [&quot;漢字&quot;, &quot;汉字&quot;] - name: ascii_punct states: [&quot;。，&quot;, &quot;．，&quot;] 如果是原生的输入法，则在输入界面按 F4 选择简体即可。 横排添加 ibus_rime.yaml 或 ibus_rime.custom.yaml ，部署没反应就添加另一个，反正这两个必有一个可用。此项配置选词列表横排显示。 12style: horizontal: true 同步编辑 installation.yaml， 空白行填入 sync_dir: ‘同步目录’，然后修改 installation_id 的值为一个有意义的名字。Rime 执行同步时将会导出所有的配置文件和用户字典到 ~/同步目录/installation_id 文件夹下 nstallation.yaml 配置如下： 12345678distribution_code_name: &quot;ibus-rime&quot;distribution_name: Rimedistribution_version: 1.5.0install_time: &quot;Mon Jan 3 13:19:31 2022&quot;installation_id: &quot;ibus-rime&quot;rime_version: 1.7.3sync_dir: 'RimeSync' 执行同步后将会导出配置和用户字典在 ~/RimeSync/ibus-rime 文件夹下。 其中的 luna_pinyin.userdb.txt 文件就是明月拼音的用户字典文件（双拼方案是基于明月拼音的，使用明月拼音的词典），它记录了你的词频等信息，词库养得越久越好用。 要养成经常同步并备份的好习惯！ 词库rime 提供的词典管理工具是 rime_dict_manager，可以导入导出用户词库 导入用户词库 导入方法：在 rime 的配置目录下执行 ： 1rime_dict_manager -i 词典名 词典文件 对于明月拼音（以及双拼）,使用的词典是 luna_pinyin，所以命令应该是： 1rime_dict_manager -i luna_pinyin 词典文件 注意：这个工具不会搜索 rime 的配置文件目录位置，只是在当前目录下生成转化的文件，所以必须在 rime 的配置文件目录下使用这个工具才能有效果！ 导出用户词库 一般不需要手动进行这个操作，因为同步的时候会导出用户词库 导出方法：在 rime 的配置目录下执行： 1rime_dict_manager -e 词典名 输出的词典文件名 模糊音编辑输入法对应的文件，如小鹤双拼 double_pinyin_flypy.schema.yaml 文件，在 speller/algebra 下的 xform 字段之前添加对应的模糊音设置。视需求添加。 123456789101112131415161718192021222324252627patch: 'speller/algebra': - erase/^xx$/ # 第一行保留 # 模糊音定義 - derive/^([zcs])h/$1/ # zh, ch, sh =&gt; z, c, s - derive/^([zcs])([^h])/$1h$2/ # z, c, s =&gt; zh, ch, sh - derive/^n/l/ # n =&gt; l - derive/^l/n/ # l =&gt; n - derive/^r/l/ # r =&gt; l - derive/^ren/yin/ # ren =&gt; yin, reng =&gt; ying - derive/^r/y/ # r =&gt; y # 下面 hu &lt;=&gt; f 這組寫法複雜一些，分情況討論 - derive/^hu$/fu/ # hu =&gt; fu - derive/^hong$/feng/ # hong =&gt; feng - derive/^hu([in])$/fe$1/ # hui =&gt; fei, hun =&gt; fen - derive/^hu([ao])/f$1/ # hua =&gt; fa, ... - derive/^fu$/hu/ # fu =&gt; hu - derive/^feng$/hong/ # feng =&gt; hong - derive/^fe([in])$/hu$1/ # fei =&gt; hui, fen =&gt; hun - derive/^f([ao])/hu$1/ # fa =&gt; hua, ... # 韻母部份 - derive/^([bpmf])eng$/$1ong/ # meng = mong, ... - derive/([ei])n$/$1ng/ # en =&gt; eng, in =&gt; ing - derive/([ei])ng$/$1n/ # eng =&gt; en, ing =&gt; in 皮肤配色如果是 ibus ，那更改不了配色，ibus 的配色是与系统主题一致的，如果是 fcitx ，在 custom 配置里修改即可。 重新部署点击部署或 ibus-daemon -drx 参考Linux 下 rime 输入法小鹤双拼配置 luna_pinyin.custom.yaml Rime 定製指南 UserGuide 致第一次安装 RIME 的你","link":"/2021/03/11/rime%E7%9A%84Linux%E9%85%8D%E7%BD%AE/"},{"title":"rsync-Linux工具小记","text":"rsync 是一个常用的 Linux 应用程序，用于文件同步。rsync 是”远程同步”（remote sync）的意思。与其他文件传输工具（如 FTP 或 scp）不同，rsync 的最大特点是会检查发送方和接收方已有的文件，仅传输有变动的部分（默认规则是文件大小或修改时间有变动）。 它可以在本地计算机与远程计算机之间，或者两个本地目录之间同步文件（但不支持两台远程计算机之间的同步）。它也可以当作文件复制工具，替代cp和mv命令。 本笔记记录一些入门参数和用法。 安装Ubuntu下，一般来说，不是最简安装的系统应该都已经自带。 12sudo apt-get updatesudo apt-get install rsync 参数用法12345678910111213141516-a 这是归档模式，表示以递归方式传输文件，并保持所有属性，它等同于-r、-l、-p、-t、-g、-o、-D 选项。-a 选项后面可以跟一个 --no-OPTION，表示关闭 -r、-l、-p、-t、-g、-o、-D 中的某一个，比如-a --no-l 等同于 -r、-p、-t、-g、-o、-D 选项。-r 表示以递归模式处理子目录，它主要是针对目录来说的，如果单独传一个文件不需要加 -r 选项，但是传输目录时必须加。-v 表示打印一些信息，比如文件列表、文件数量等。-l 表示保留软连接。-L 表示像对待常规文件一样处理软连接。如果是 SRC 中有软连接文件，则加上该选项后，将会把软连接指向的目标文件复制到 DEST。-p 表示保持文件权限。-o 表示保持文件属主信息。-g 表示保持文件属组信息。-D 表示保持设备文件信息。-t 表示保持文件时间信息。--delete 表示删除 DEST 中 SRC 没有的文件。--exclude=PATTERN 表示指定排除不需要传输的文件，等号后面跟文件名，可以是通配符模式（如 *.txt）。--progress 表示在同步的过程中可以看到同步的过程状态，比如统计要同步的文件数量、 同步的文件传输速度等。-u 表示把 DEST 中比 SRC 还新的文件排除掉，不会覆盖。-z 加上该选项，将会在传输过程中压缩。-n 模拟运行，相当于测试。 用法示例-r-r表示递归（recursion），即包含子目录。 1rsync -r source destination -a这是归档模式，表示以递归方式传输文件，并保持所有属性，它等同于-r、-l、-p、-t、-g、-o、-D 选项。-a 选项后面可以跟一个 –no-OPTION，表示关闭 -r、-l、-p、-t、-g、-o、-D 中的某一个，比如-a –no-l 等同于 -r、-p、-t、-g、-o、-D 选项。 比-r常用，一般直接用-a 1rsync -a source destination 如在 source 后加 / ，即 source/ 则表示只同步源目录的内容到目标目录，不是整个文件夹都同步。如果不加，则会在 destination 下添加整个 source 目录，结构则为 destination/source -n-n参数模拟命令执行的结果，并不真的执行命令。可以加上 -v 查看输出结果。 1rsync -anv source destination –delete默认情况下，rsync 只确保源目录的所有内容（明确排除的文件除外）都复制到目标目录。它不会使两个目录保持相同，并且不会删除文件。如果要使得目标目录成为源目录的镜像副本，则必须使用--delete参数，这将删除只存在于目标目录、不存在于源目录的文件。 1rsync -a --delete source destination 上面命令中，--delete参数会使得destination成为source的一个镜像。 –exclude有时，我们希望同步时排除某些文件或目录，这时可以用--exclude参数指定排除模式。 如：不同步所有隐藏文件。 1rsync -a --exclude '.*' source destination 可以多次使用满足不同的排除需求；或bash大括号扩展；或逐行写入文件里，指定到该文件。 123rsync -a --exclude '.*' --exclude '*.txt' source destinationrsync -a --exclude={'.*','*.txt'} source destinationrsync -a --exclude-from='exclude-file.txt' source destination –include--include参数用来指定必须同步的文件模式，往往与--exclude结合使用。 1rsync -a --include=&quot;*.txt&quot; --exclude='*' source/ destination 上面命令指定同步时，排除所有文件，但是会包括 TXT 文件。 同步模式rsync支持本地同步（如上参数示例），也支持远程同步。 123rsync -av source username@remote_host:destinationrsync -av username@remote_host:source destinationrsync -av -e 'ssh -p 2234' source/ user@remote_host:/destination 可使用 -e 指定ssh协议命令 基准同步除上，还可以设置基准目录以同步。 rsync 还支持使用基准目录，即将源目录与基准目录之间变动的部分，同步到目标目录。 具体做法是，第一次同步是全量备份，所有文件在基准目录里面同步一份。以后每一次同步都是增量备份，只同步源目录与基准目录之间有变动的部分，将这部分保存在一个新的目标目录。这个新的目标目录之中，也是包含所有文件，但实际上，只有那些变动过的文件是存在于该目录，其他没有变动的文件都是指向基准目录文件的硬链接。 --link-dest参数用来指定同步时的基准目录。 1rsync -a --delete --link-dest /compare/path /source/path /target/path 上面命令中，--link-dest参数指定基准目录/compare/path，然后源目录/source/path跟基准目录进行比较，找出变动的文件，将它们拷贝到目标目录/target/path。那些没变动的文件则会生成硬链接。这个命令的第一次备份时是全量备份，后面就都是增量备份了。 参考rsync用法教程 Linux rsync命令用法详解","link":"/2022/03/31/rsync-Linux%E5%B7%A5%E5%85%B7%E5%B0%8F%E8%AE%B0/"},{"title":"shell 脚本入门","text":"shell 是一种脚本语言，是用户与内核通信的一种方式。Linux上常见的Shell脚本解释器有bash、sh、csh、ksh等。一般来说 bash 是默认的 shell。 查看系统默认解释器：echo $SHELL 运行运行前赋权 1chmod +x hello.sh 作为解释器参数运行解释器，脚本作为其参数。 1/bin/bash hello.sh 这种方式无视解释器首行配置的解释器信息。 直接执行12cd path./hello.sh 需要写成 ./ 的开头，如果不写，实际上系统会去 PATH 内寻找脚本，但 PATH 里只有 /bin，/usr/bin 之类的，所以启动会失败。 脚本头1#!/bin/bash 指定脚本的解释器 变量变量名与等号间不能有空格，命名使用英文，下划线，数字，不能以数字开头。如 bar=hello。不能使用关键字，–help 查看关键字。 类型 局部变量：在脚本或命令中定义，仅在当前shell中有效，其他shell启动的程序不能访问局部变量。 环境变量：所有的程序，包括shell启动的程序，都能访问环境变量。必要的时候shell脚本也可以定义环境变量。 shell变量：shell变量是由shell程序设置的特殊变量。shell变量中有一部分是环境变量，有一部分是局部变量。 使用定义的变量，使用时在前加 $ 表示引用。可以被重新定义。引用时也可以在变量外套花括号作为边界区分，避免被解释器把握为一个新的空变量。如 ${foo}bar 和 $foobar 只读对变量执行 readonly ，使其成为只读变量 1234foo=123readonly foofoo=456#This variable is read only 删除删除了再用就是空变量了。无法删除只读变量 1unset foo 字符串shell里的数据类型也就数字和字串。使用字符串时，单双引号都可以。需要注意的是，单引号字串中不能出现单独一个的单引号，用转义符也不行，但是可以成对使用表示字符串的拼接。 双引号里可以有变量，双引号里可以用转义字符。 以拼接字符串作为例子 12345678910foo=&quot;example&quot;# 双引号test1=&quot;this is an &quot;$foo&quot;&quot;test2=&quot;this is an ${foo}&quot;# this is an example# 单引号test3='this is an '$foo''test4='this is an ${foo}'# this is an example, this is an ${foo} 字符串操作 长度 提取子串 查找子串 12345678910string=&quot;string&quot;echo ${#string} # 6echo ${string:1:3} # triecho `expr index &quot;$string&quot; tr` # 2echo `expr index &quot;$string&quot; gt` # 2echo `expr index &quot;$string&quot; s` # 1# 用反引号``括起。搜索子串返回最先找到的那一个。# 实际上还可以用正则、grep等等方式 数组bash 只支持一维数组 12345array=(val0,val1)echo $(array[1])echo $(array[@]) # 输出所有元素length=${#array[@]} #元素个数 命令算符一如既往，有算数运算符，关系运算符，布尔运算符，字符串运算符，文件测试运算符。 bash 不支持数学运算，一般还得用 expr，其中乘法 * 需要转义 \\* 12345sum=`expr 2 + 4` #反引号和空格需要留意echo &quot;sum=$sum&quot; #sum=5sum=2+4echo $sum #输出2+4 关系运算符：-eq 相等，-ne 不等，-gt &gt; ，-lt &lt; ，-ge &gt;= ，-le &lt;= 布尔与逻辑算符：布尔（ ! 非，-o 或， -a 与），逻辑（ &amp;&amp; 逻辑与， || 逻辑或），单括号 [ 中 -a 等价于双括号 [[ 中的 &amp;&amp; 逻辑与。其他类似。 123if [[ $a -eq $b || $a -lt $b ]]; then echo &quot;yes&quot;; fi #yesif true || true;then echo &quot;YES&quot;; else echo &quot;NO&quot;; fi #yesif [ $a -eq $b -o $a -lt $b ]; then echo &quot;yes&quot;; fi #yes echo &amp; printfecho一般是 123echo &quot;hello&quot;# 如果要输出命令结果echo `date` #2020年 04月 ... (需要用反引号将命令引起) echo 自动添加换行符，printf 则不会，需要自己添加 \\n 12printf &quot;%-10s %-8s %-4s\\n&quot; 日期 星期 价格 printf &quot;%-10s %-8s %-4.2f\\n&quot; 20.3 五 66.1234 %s %c %d %f 都是格式替代符，％s 输出一个字符串，％d 整型输出，％c 输出一个字符，％f 输出实数，以小数形式输出。 %-10s 指一个宽度为 10 个字符（- 表示左对齐，没有则表示右对齐），任何字符都会被显示在 10 个字符宽的字符内，如果不足则自动以空格填充，超过也会将内容全部显示出来。 %-4.2f 指格式化为小数，其中 .2 指保留2位小数。 test检验条件成立 123if test 5 -eq 5;then echo &quot;YES&quot;; else echo &quot;NO&quot;; fiif test -n &quot;not empty&quot;;then echo &quot;YES&quot;; else echo &quot;NO&quot;; fiif test -f /boot/System.map; then echo &quot;YES&quot;; else echo &quot;NO&quot;; fi 控制if else123456789if conditionthen commandelif conditionthen commandelse commandfi 以 fi 结尾以示 if，同时，流程不可以为空，没有 else 的命令执行就不要写 else 分支。 for1234567for var in item1 item2 ... itemNdo command1 command2 ... commandNdone while1234while conditiondo commanddone until1234until conditiondo commanddone case12345678case val in case1) command1 ;; case2) command2 ;;esac 两个分号 ;; 表示 break 12345678word=&quot;hello&quot;case &quot;$word&quot; in &quot;hello&quot;) echo &quot;hi!&quot; ;; &quot;bye&quot;) echo &quot;bye!&quot; ;;esac break continue在循环过程中，有时候需要在未达到循环结束条件时强制跳出循环，两个命令来实现：break和continue。 break命令允许跳出所有循环（终止执行后面的所有循环）。continue不会跳出所有循环，仅仅跳出当前循环。 参考Shell实验手册","link":"/2020/04/12/shell%20%E8%84%9A%E6%9C%AC%E5%85%A5%E9%97%A8/"},{"title":"typora图片自动上传","text":"Typora 使用已经很久了，作为一个 Markdown 编辑器，确实很不错。在之前，图文编辑我是把图片留在本地的，但一旦路径更改、图片移动、数据库转移等等，文章里的图就全都寄了，所以就打算把图弄到云上去好了。 方案选定编辑器还是 Typora 的，这个没什么问题。上传模块上，有 Typora-plugins-win-img 和 PicGo 等，考虑到 Typora 的偏好设置内有自带的 PicGo 内核可以选，支持性应该好很多，最后选了 PicGo。 云的方面，看了很多文章，有 Gitee 的，GitHub 的，Bilibili 图床的，自建的，各大云厂商的 cos 服务的，各有优缺点。 使用代码仓库托管的模式确实很不错，相当于白嫖，但是有一个问题就是，图片量大了之后需要新建仓库（大于1G，虽然经过思考和计算，我不知道猴年马月才攒够1G的博客内图片），而且是公有仓库，私密性差了点，另外本来博客挂在 GitHub Page 在国内不施法访问已经拉得不行了，再整个图床，那可真是雪上加霜。Gitee 的话，前面列举的点也没有解决，所以白嫖虽好，但我不选。但可以作为一个备选方案，以后把 Gitee 镜像站做了再说。 各厂商诸如 Bilibili 图床，有跑路的风险，技术和支持也是烂，纯下策。七牛云，又拍云，腾讯云之类的，个人使用还是挺便宜的，一年都没有几十块，最后选了腾讯云，因为腾讯云有优惠，相当于免费一年，以后升价什么的再说吧（一年都写不了几篇，存不了几块钱）。 Typora在偏好设置的图片中，选择对图片应用上传，选择服务为 PicGo(app) ，如果是 win 端，执行路径选择对应的文件夹路径就好了。Linux 的话，因为安装是使用 AppImage ，直接把 AppImage 的路径写好就行，如果是 Arch Linux ，还是下一个 AppImage Laucher 安装一下（Arch 虽好，但我必不会再用），最后点测试就好。 PicGo在其 GitHub Releases 下好正常安装运行就行。 配置以腾讯云为例，使用子帐号创建密钥，复制到 PicGo 填写 SecretId 和 SecretKey ，其中 APPID 是子帐号号码。 上传区选好腾讯云COS，即可完成搭建。 云这里选择了腾讯云，购买COS的标准服务即可，创建存储桶和文件夹，对子帐号授权，基本就是这些云端服务基操。 基本就是这些，简短记录一下。","link":"/2021/11/02/typora%E5%9B%BE%E7%89%87%E8%87%AA%E5%8A%A8%E4%B8%8A%E4%BC%A0/"},{"title":"Welcome","text":"欢迎访问戴闻濠的博客。还没想好写什么，不过可以随时改，先这样吧。","link":"/2020/06/30/welcome/"},{"title":"利用github构建静态博客数据库","text":"引言因为使用如hexo的框架搭建博客，是静态的，但是难免会有一些使用动态数据的需求产生，面对这些需求时，选择机械地编写硬编码，再上传生成显然不是一个优雅的做法。 而目前大多框架的主题都带有评论系统，其中支持gitalk的便使用了OAuth以及github中的issue，通过OAuth授权验证，issue作为存储。那么我们可以考虑利用这种模式，将动态数据更新到特定repo的某个issue中，再通过github提供的API访问获取数据。除此之外，关于这个存储repo，虽然不能私有，但是其中的issue可以选择关闭，只有管理员可以浏览编辑。这就只剩下一个问题，数据泄露，如果有比较机密的数据，当然不适合用这种方法了。（不会真有人往博客里写秘密吧，谁把秘密写在博客里，能写在博客的那能叫秘密吗？） 认识gitalk看明白gitalk的工作原理，就成功大半了。 我，前端菜鸡，看到前端代码就头疼，能瞎写绝不优化。差不多就行了。 github token此章参考Gitalk 运作原理，Gitalk，Github文档。token分为三类，gitalk使用OAuth App，属于github的三种token`之一。 GitHub Apps OAuth Apps Personal access tokens OAuth Apps实现了OAuth2.0认证协议，主要针对第三方平台想要通过GitHub API获取用户私密信息时，用户可不必向第三方平台提供GitHub账号密码即可完成认证。通过OAuth Apps授权的token代表的是该授权用户，而不是App，即App本身不具有任何权限。在权限限制上也与GitHub App不同，OAuth App只能读。值得一提的是GitHub使用的是Authorization code grant模式，也是最推荐的模式。以gitalk为例在该模式下的认证流程为 OAth2.0 协议OAuth2 有4个角色： 资源拥有者 (user) 第三方客户端 (client) 资源服务器 (resource server) 认证服务器 (authentication server) Authentication code grant 模式流程如下： user在第三方平台A登录，登录方式是使用另一个平台B的身份信息。 A携带clientID跳转到B的授权页，请user授权。（这个clientID就是A在B登记的OAuth身份标识，这也表明使用OAuth协议前必须先在平台注册登记） user授权A可以从B获取身份信息，grant_code作为凭据。 A的【后台】向B发起access_token申请，携带参数clientID+clientSecret+grant_code。 B验证无误后返回代表该用户的access_token。 A可以使用access_token通过B的API调取user信息了。 可以看出认证授权有两个阶段，这也是OAuth协议被认为安全的关键。第一阶段只能拿到一个临时许可令牌grant_code，可能十几分钟的过期。第二阶段拿access_token。 第一阶段clientID可以保存在前端，比如web页面，跳转认证时直接从前端取，不需要请求后台。grant_code只作为一个用户许可，并不能确保是否是可信任平台发起的请求，所以要验证平台是否可信，通过clientSecret。 第二阶段clientSecret只能保存在后台，而且获取access_token的请求只能由后台服务器发起和接收。这个过程跟前端无关，所以被认为是最安全的。 access_token一般会被保存起来，过期时间会久一些，可能几个月。 既然如此，是否可以说凡是使用OAuth2.0的认证就一定是最安全的呢？并不是，这要看是否使用的规范。gitalk就是一个不规范使用的例子，它把clientSecret也暴露在前端。因为我们没有后台。无后台server。缺点是暴露了clientSecret，不符合OAuth2.0规范。但是在GitHub上这样做是安全的，因为access_token只有读权限，不能对user的repo造成任何损害。 gitalk源码gitalk没有后台server，clientSecret也是保存在前端，它的代理服务器地址。gitalk的代码，使用的代理 1proxy: 'https://cors-anywhere.herokuapp.com/https://github.com/login/oauth/access_token', 一个公开的免费代理，声称是不会保存任何转发信息。 access_token 1234567get accessToken () {return this._accessToke || window.localStorage.getItem(GT_ACCESS_TOKEN)}set accessToken (token) {window.localStorage.setItem(GT_ACCESS_TOKEN, token)this._accessToken = token} access_token获取之后被保存起来，不关闭浏览器是不需要重复授权的。 comments 123456createIssue () { const { owner, repo, title, body, id, labels, url } = this.options return axiosGithub.post(`/repos/${owner}/${repo}/issues`, { title, labels: labels.concat(id), body: body || `${url} \\n\\n ${ 注意labels后面连接的id，这个id就是文章的唯一标识，一般设置为URL。 GitHub的label长度限制在63字符之内，超过就不能创建Issue。为此可以对URL进行md5哈希，md5后生成128-bit摘要，用16进制表示，长度恒等于32. Issues获取也是根据labels，不同文章的id不同，获取的列表自然也就不同，把Issues作为评论展示出来，这样一个简单的评论系统就完成了。 读取issue这个简单，通过github api就完事了，有一定的次数限制，不过可以添加token授权来解除上限，带上token后续也可以做一些其他的操作，上锁、删除等等。 官方文档：issue API 主要用到的就是获取具体内容，其中的评论等。 1234get https://api.github.com/repos/USER_NAME/repo_NAME/issues/number// 获取第几个issue的内容get https://api.github.com/repos/USER_NAME/repo_NAME/issues/number/comments// 获取第几个issue的评论内容，读取其中的body再解析就行了。 写个XMLHttpRequest请求。 写入issue写入比较麻烦，因为只读的请求是可以匿名的，写入修改是需要授权的，需要编写授权跳转页面，api地址https://github.com/login/oauth/authorize?client_id=YOUR_CLIENT_ID&amp;redirect_uri=http://localhost:8000/home.html 授权之后构造符合post请求的信息发送就可以了，但是要带上token,其中如果使用access token，不能直接明文记录，会被删除，可以分段记录在不同的变量拼接，当然了，会有一定的泄露风险，不过无所谓，只要授权不是最高级别的也没多大问题。 使用octokit但是以上直接通过github API造轮子的办法比较繁琐，文档也没有太多例子，构造、测试非常的麻烦。所以可以直接用轮子，文档：octokit/rest.js，github页面：octokit/rest.js官方描述如下GitHub REST API client for JavaScript，直接查文档就行了。构造octokit对象，把参数填完就可以了。非常方便。 octokit使用注意事项因为使用octokit需要引入模块，官方给出了两种方式。 浏览器 Load @octokit/rest directly from cdn.skypack.dev 123&lt;script type=&quot;module&quot;&gt; import { Octokit } from &quot;https://cdn.skypack.dev/@octokit/rest&quot;;&lt;/script&gt; Node Install with npm install @octokit/rest 12const { Octokit } = require(&quot;@octokit/rest&quot;);// or: import { Octokit } from &quot;@octokit/rest&quot;; 如果使用浏览器的话，直接引用，在script标签里编写函数就可以了。 如果在js文件中使用第二种方式，大概率会报错：Uncaught ReferenceError：require is not defined，因为浏览器环境没有RequireJS，需要另外引入，比较麻烦。可以通过加载定义Require的库，或者使用browerify,webpack等工具将js文件重新打包成带依赖的文件，但是会变大很多。建议还是使用第一种方式。 实例读取issue读取issue >folded1234567891011121314var onload = function () { var url = &quot;https://api.github.com/repos/User_name/repo_name/issues/issue_id;&quot;; var request = new XMLHttpRequest(); var clientID = 'YOUR_clientID'; var clientSecret = 'YOUR_clientSecret'; var req = new XMLHttpRequest(); req.open('GET', url, true); req.send(null); req.onload = function(){ if(req.status === 200){ var json = JSON.parse(req.responseText); } }} 按需解析json即可，匿名读取有限制，每分钟60次，一般没问题，如果需要解除限制，就带上clientID和Secret区请求。 使用octokit使用octokit的实例 >folded123456789101112131415161718192021222324252627&lt;body&gt; &lt;p id=&quot;pre&quot;&gt;hello&lt;/p&gt; &lt;p id=&quot;next&quot;&gt;bye&lt;/p&gt; &lt;script type=&quot;module&quot;&gt; import { Octokit } from &quot;https://cdn.skypack.dev/@octokit/rest&quot;; var pre = document.getElementById(&quot;pre&quot;); pre.onclick = function(){ console.log(&quot;hello&quot;) } next.onclick = function(){ const octokit = new Octokit({ auth:&quot;your_access_token&quot;, userAgent: 'myApp v1.2.3' }) octokit.rest.issues.createComment({ owner:&quot;name&quot;, repo:&quot;repo_name&quot;, issue_number:issue_id, body:&quot;The content you want to send.&quot;, }); } &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;&gt; 其他的octokit编写也差不多，看文档配参数就行，文档十分完善。 一些bug构建js代码时，会在hexo博客上遇到一些坑，一般是因为其他插件造成的，比如Aplayer的代码注入或是重复载入 Aplayer.js 资源脚本问题，会在js文件头部注入&lt;link&gt;标签，导致报错， 查阅官方文档给出的方式是在配置文件中加入 12aplayer: asset_inject: false 但也很可能没有卵用！最好的方式就是，卸载APlayer，然后重装一个hexo-tag-aplayer（反正我也不在页面内插入音乐盒子，文章里用hexo-tag-aplayer就够了），然后再添加上述配置。 参考gitalk：https://github.com/gitalk/gitalk 利用 github pages 与 github api 搭建博客：https://github.com/eyasliu/blog/issues/2 gitalk的运作原理：https://carl-zk.github.io/blog/2020/03/03/gitalk-%E8%BF%90%E4%BD%9C%E5%8E%9F%E7%90%86/ github Issue 作为博客微型数据库的应用：https://removeif.github.io/theme/github-Issue-%E4%BD%9C%E4%B8%BA%E5%8D%9A%E5%AE%A2%E5%BE%AE%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%BA%94%E7%94%A8.html 透过Github Action生成数据：https://blog.uiharu.top/archives/generate-links-json-via-github-action.html 利用github api获取issue的想法：https://github.com/isaaxite/blog/issues/44 github文档的issues操作：https://docs.github.com/en/rest/reference/issues github API的调用教程：https://segmentfault.com/a/1190000015144126 利用github issue实现评论插件：https://segmentfault.com/a/1190000011100934 octokit文档：https://octokit.github.io/rest.js/v18 解决require问题：https://stackoverflow.com/questions/19059580/client-on-node-js-uncaught-referenceerror-require-is-not-defined 使用hexo-tag-aplayer以及配置书写：https://easyhexo.com/3-Plugins-use-and-config/3-1-hexo-tag-aplayer/#%E4%BB%8B%E7%BB%8D 解决Aplayer注入问题：https://blog.csdn.net/qq_27439819/article/details/105011943","link":"/2020/06/30/%E5%88%A9%E7%94%A8github%E6%9E%84%E5%BB%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"title":"博客多端部署、同步","text":"hexo 自带的提交 hexo -d 提交的是博客生成的 html 文件，如果需要多端同步，需要源码一并提交。使用 Git 进行上传、拉取、同步管理。了解了一下大致有两种做法，一种是将源码上传到原来的 github 网页博客项目的新分支，这样意味着所有源文件都公开，虽然也没啥，但是就是不太爽。另一种就是创建新的私有库，存储源代码，写博客、发布博客前，先拉取，后上传即可。 本地部署要在不同终端部署博客，需要建立相似的版本环境。 安装指定版本的nodejs指定版本源，指定为14版本 12345curl -sL https://deb.nodesource.com/setup_14.x | sudo -E bash -sudo apt-get updatesudo apt-get install nodejsnode -vnpm -v 安装git12sudo apt install git-allgit --version 安装Hexo123456789101112131415npm install hexo@5.4.0npm install hexo@legacynpm i hexo-cli -g#安装指定版本npm install hexo@4#安装某版本的最新包npm view &lt;package_name&gt; versionnpm info &lt;package_name&gt;#查看包的最新版本信息npm listnpm list &lt;package_name&gt;#列出已安装包/列出指定包的版本信息#安装完毕后hexo -v 安装必要的依赖包123npm install npm-check-updates -g #检查包更新npm install @octokit/rest #评论插件npm install hexo-theme-icarus #主题文件 同步创建私有仓库github 上创建私有仓库 初始源上传github编写 .gitignore ，没有就创建一个，用于忽略指定文件不同步。 12345/.deploy_git/public/node_modules/*.logdb.json 12345678910git initgit remote add origin git@github.com:your_name/repo_name.git#连接到远程仓库，别名origingit remote -v#查看连接git pull origin main --allow-unrelated-historiesgit add -Agit commit -m &quot;blogsource&quot;git pushgit push --set-upstream origin main 合并分支因为 github 将原本默认的 master 分支更改为 main 。所以有的旧仓库需要合并分支。不想合并其实只需要将 master 重新改为默认分支就好，不过这样新旧项目的默认主分支就不同了，有点麻烦。 克隆仓库 1git clone repo_name.git 创建 main 并推送 12git checkout -b maingit push origin main 删除本地、远端 master 12git branch -d mastergit push oringin master 拉取代码1git pull origin main 多端同步初始化密钥。如果有多个帐号的需求，请不要使用全局配置。 1234567git config --global user.name &quot;yourGithubName&quot;git config --global user.email &quot;yourGithubEmail&quot;ssh-keygen -t rsa -C &quot;yourGithubEmail&quot;#然后查看密钥，复制到github个人帐号，创建新的settings/SSH Keyscat ~/.ssh/id_rsa.pub#测试ssh -T git@github.com 然后 123git initgit remote add origin githubUserName/repoName.gitgit clone git@github.com:githubUserName/repoName.git 回到目录下 1npm install 报错就重开终端，文件夹数据、属性没刷新。 至此，完成多端的同步设置。使用 git pull 查看，最新。 日常使用上传、写博客 12345git pullgit add .git commit -m &quot;sync&quot;git push origin main# hexo g -d？ 维护博客还是需要时不时维护一下的，特别是那帮搞前端的天天升级依赖包，哪天哪个依赖包升级了，就开始疯狂报错了。一年多没有维护的博客可以说是基于bug运行了。（我更新依赖把博客滚挂了） 1234npm install npm-check-updates -gncuncu -u #升级依赖包npm audit fix #修复依赖包安全漏洞 github action自动部署另见笔记：GitHub Action入门指南—实战-自动部署小节。 每次写完，不仅要 push ，还要 hexo g -d ，确实是不太优雅，自动部署配置好 Action 之后，每次 push 完就可以溜了，好多了。 关键文件备份hexo 以及各种主题，都是博客的载体罢了，不管博客服务有没有正常运行，有没崩溃，都有需要备份的数据，便以归档、重建。 参考Hexo 博客多终端同步管理 Hexo 多终端同步和管理 Hexo 官方文档-资源文件夹","link":"/2022/02/26/%E5%8D%9A%E5%AE%A2%E5%A4%9A%E7%AB%AF%E9%83%A8%E7%BD%B2%E3%80%81%E5%90%8C%E6%AD%A5/"},{"title":"日麻入门","text":"虽然是个运气游戏，或者说是运七技三的游戏，但还是可以有把控牌型的做法的，合理的做牌方式，可以提高胡牌概率。（蒙特卡洛树云云）作为一个在运气游戏中也希望能够有依据，讲科学地打牌的非洲人（不是魔法少女不适合打麻将啊！），对科学麻将的研究当然十分重要。（毕竟真实麻将里可不会有什么海底捞月、岭上开花的魔法）只有像小和和一样讲科学才能赢！","link":"/2021/07/14/%E6%97%A5%E9%BA%BB%E5%85%A5%E9%97%A8/"},{"title":"HTML笔记","text":"HTML的一些知识点。其实到处都能查到，也不经常写，搞懂就行，标签乱七八糟的，要用再查吧。 标签作为标记性语言，没有编译过程，由浏览器解析。标签即用于给文本增加语义。 html骨架标签 标签名 定义 说明 &lt;html&gt;&lt;/html&gt; HTML标签 页面中最大的标签，我们成为根标签 &lt;head&gt;&lt;/head&gt; 文档的头部 注意在head标签中我们必须要设置的标签是title &lt;titile&gt;&lt;/title&gt; 文档的标题 让页面拥有一个属于自己的网页标题 &lt;body&gt;&lt;/body&gt; 文档的主体 元素包含文档的所有内容，页面内容基本都是放到body里面的 常用标签常用标签 >folded12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE&gt; 定义文档类型。&lt;html&gt; 定义一个 HTML 文档&lt;title&gt; 为文档定义一个标题&lt;body&gt; 定义文档的主体&lt;h1&gt; to &lt;h6&gt; 定义 HTML 标题&lt;p&gt; 定义一个段落&lt;br&gt; 定义简单的折行。&lt;hr&gt; 定义水平线。&lt;!--...--&gt; 定义一个注释&lt;b&gt;定义粗体文本。&lt;i&gt; 定义斜体文本。&lt;strong&gt; 定义语气更为强烈的强调文本。&lt;sub&gt; 定义下标文本。&lt;sup&gt; 定义上标文本。&lt;form&gt; 定义一个 HTML 表单，用于用户输入。&lt;input&gt; 定义一个输入控件&lt;textarea&gt; 定义多行的文本输入控件。&lt;button&gt; 定义按钮。&lt;select&gt; 定义选择列表（下拉列表）。&lt;img&gt; 定义图像。&lt;a&gt; 定义一个链接&lt;link&gt; 定义文档与外部资源的关系。&lt;ul&gt; 定义一个无序列表&lt;ol&gt; 定义一个有序列表&lt;li&gt; 定义一个列表项&lt;table&gt; 定义一个表格&lt;caption&gt; 定义表格标题。&lt;th&gt; 定义表格中的表头单元格。&lt;tr&gt; 定义表格中的行。&lt;td&gt; 定义表格中的单元。&lt;thead&gt; 定义表格中的表头内容。&lt;tbody&gt; 定义表格中的主体内容。&lt;style&gt; 定义文档的样式信息。&lt;div&gt; 定义文档中的节。&lt;head&gt; 定义关于文档的信息&lt;meta&gt; 定义关于 HTML 文档的元信息。&lt;script&gt; 定义客户端脚本。 全部标签全部标签 >folded123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131基础&lt;!DOCTYPE&gt; 定义文档类型。&lt;html&gt; 定义一个 HTML 文档&lt;title&gt; 为文档定义一个标题&lt;body&gt; 定义文档的主体&lt;h1&gt; to &lt;h6&gt; 定义 HTML 标题&lt;p&gt; 定义一个段落&lt;br&gt; 定义简单的折行。&lt;hr&gt; 定义水平线。&lt;!--...--&gt; 定义一个注释格式 &lt;acronym&gt; HTML5不再支持。 定义只取首字母的缩写。&lt;abbr&gt; 定义一个缩写。&lt;address&gt; 定义文档作者或拥有者的联系信息。&lt;b&gt; 定义粗体文本。&lt;bdi&gt;New 允许您设置一段文本，使其脱离其父元素的文本方向设置。&lt;bdo&gt; 定义文本的方向。&lt;big&gt; HTML5不再支持。 定义大号文本。&lt;blockquote&gt; 定义块引用。&lt;center&gt; HTML5不再支持。 HTML 4.01 已废弃。定义居中文本。&lt;cite&gt; 定义引用(citation)。&lt;code&gt; 定义计算机代码文本。&lt;del&gt; 定义被删除文本。&lt;dfn&gt; 定义定义项目。&lt;em&gt; 定义强调文本。 &lt;font&gt; HTML5不再支持。 HTML 4.01 已废弃。 定义文本的字体、尺寸和颜色&lt;i&gt; 定义斜体文本。&lt;ins&gt; 定义被插入文本。&lt;kbd&gt; 定义键盘文本。&lt;mark&gt;New 定义带有记号的文本。&lt;meter&gt;New 定义度量衡。仅用于已知最大和最小值的度量。&lt;pre&gt; 定义预格式文本&lt;progress&gt;New 定义运行中的任务进度（进程）。&lt;q&gt; 定义短的引用。&lt;rp&gt;New 定义不支持 ruby 元素的浏览器所显示的内容。&lt;rt&gt;New 定义字符（中文注音或字符）的解释或发音。&lt;ruby&gt;New 定义 ruby 注释（中文注音或字符）。&lt;s&gt; 定义加删除线的文本。&lt;samp&gt; 定义计算机代码样本。&lt;small&gt; 定义小号文本。&lt;strike&gt; HTML5不再支持。 HTML 4.01 已废弃。 定义加删除线的文本。&lt;strong&gt; 定义语气更为强烈的强调文本。&lt;sub&gt; 定义下标文本。&lt;sup&gt; 定义上标文本。&lt;time&gt;New 定义一个日期/时间&lt;tt&gt; HTML5不再支持。 定义打字机文本。&lt;u&gt; 定义下划线文本。&lt;var&gt; 定义文本的变量部分。&lt;wbr&gt;New 规定在文本中的何处适合添加换行符。表单 &lt;form&gt; 定义一个 HTML 表单，用于用户输入。&lt;input&gt; 定义一个输入控件&lt;textarea&gt; 定义多行的文本输入控件。&lt;button&gt; 定义按钮。&lt;select&gt; 定义选择列表（下拉列表）。&lt;optgroup&gt; 定义选择列表中相关选项的组合。&lt;option&gt; 定义选择列表中的选项。&lt;label&gt; 定义 input 元素的标注。&lt;fieldset&gt; 定义围绕表单中元素的边框。&lt;legend&gt; 定义 fieldset 元素的标题。&lt;datalist&gt;New 规定了 input 元素可能的选项列表。&lt;keygen&gt;New 规定用于表单的密钥对生成器字段。&lt;output&gt;New 定义一个计算的结果框架 &lt;frame&gt; HTML5不再支持。 定义框架集的窗口或框架。&lt;frameset&gt; HTML5不再支持。定义框架集。&lt;noframes&gt; HTML5不再支持。 定义针对不支持框架的用户的替代内容。&lt;iframe&gt; 定义内联框架。图像 &lt;img&gt; 定义图像。&lt;map&gt; 定义图像映射。&lt;area&gt; 定义图像地图内部的区域。&lt;canvas&gt;New 通过脚本（通常是 JavaScript）来绘制图形（比如图表和其他图像）。&lt;figcaption&gt;New 定义一个 caption for a &lt;figure&gt; element&lt;figure&gt;New figure 标签用于对元素进行组合。Audio/Video &lt;audio&gt;New 定义声音，比如音乐或其他音频流。&lt;source&gt;New 定义media元素 (&lt;video&gt; 和 &lt;audio&gt;)的媒体资源。media&lt;track&gt;New 为媒体(&lt;video&gt; 和 &lt;audio&gt;)元素定义外部文本轨道。&lt;video&gt;New 定义一个音频或者视频链接 &lt;a&gt; 定义一个链接&lt;link&gt; 定义文档与外部资源的关系。&lt;main&gt; 定义文档的主体部分。&lt;nav&gt;New 定义导航链接列表 &lt;ul&gt; 定义一个无序列表&lt;ol&gt; 定义一个有序列表&lt;li&gt; 定义一个列表项&lt;dir&gt; HTML5不再支持。 HTML 4.01 已废弃。 定义目录列表。&lt;dl&gt; 定义一个定义列表&lt;dt&gt; 定义一个定义定义列表中的项目。&lt;dd&gt; 定义定义列表中项目的描述。&lt;menu&gt; 定义菜单列表。&lt;command&gt;New 定义用户可能调用的命令（比如单选按钮、复选框或按钮）。表格 &lt;table&gt; 定义一个表格&lt;caption&gt; 定义表格标题。&lt;th&gt; 定义表格中的表头单元格。&lt;tr&gt; 定义表格中的行。&lt;td&gt; 定义表格中的单元。&lt;thead&gt; 定义表格中的表头内容。&lt;tbody&gt; 定义表格中的主体内容。&lt;tfoot&gt; 定义表格中的表注内容（脚注）。&lt;col&gt; 定义表格中一个或多个列的属性值。&lt;colgroup&gt; 定义表格中供格式化的列组。样式/节 &lt;style&gt; 定义文档的样式信息。&lt;div&gt; 定义文档中的节。&lt;span&gt; 定义文档中的节。&lt;header&gt;New 定义一个文档头部部分&lt;footer&gt;New 定义一个文档底部&lt;section&gt;New 定义了文档的某个区域&lt;article&gt;New 定义一个文章内容&lt;aside&gt;New 定义其所处内容之外的内容。&lt;details&gt;New 定义了用户可见的或者隐藏的需求的补充细节。&lt;dialog&gt;New 定义一个对话框或者窗口&lt;summary&gt;New 定义一个可见的标题。 当用户点击标题时会显示出详细信息。元信息 &lt;head&gt; 定义关于文档的信息&lt;meta&gt; 定义关于 HTML 文档的元信息。&lt;base&gt; 定义页面中所有链接的默认地址或默认目标。&lt;basefont&gt; HTML5不再支持。 HTML 4.01 已废弃。 定义页面中文本的默认字体、颜色或尺寸。程序 &lt;script&gt; 定义客户端脚本。&lt;noscript&gt; 定义针对不支持客户端脚本的用户的替代内容。&lt;applet&gt; HTML5不再支持。 HTML 4.01 已废弃。 定义嵌入的 applet。&lt;embed&gt;New 定义了一个容器，用来嵌入外部应用或者互动程序（插件）。&lt;object&gt; 定义嵌入的对象。&lt;param&gt; 定义对象的参数。 排版标签&lt;h1&gt;、&lt;p&gt;、&lt;hr /&gt;、&lt;br /&gt;、&lt;div&gt;、&lt;span&gt;、&lt;center&gt;、&lt;pre&gt; 标题使用&lt;h1&gt;至&lt;h6&gt;标签进行定义。&lt;h1&gt;定义最大的标题，&lt;h6&gt;定义最小的标题。具有align属性，属性值可以是：left、center、right。 段落标签&lt;p&gt;把 HTML 文档分割为若干段落。属性：align：值：left center right。属于文本级标签。 文本级标签：p、span、a、b、i、u、em。文本级标签里只能放文字、图片、表单元素。（a标签里不能放a和input） 容器级标签：div、h系列、li、dt、dd。容器级标签里可以放置任何东西。 水平线标签属性： align=&quot;属性值&quot;：设定线条置放位置。属性值可选择：left right center。 size=&quot;2&quot; ：设定线条粗细。以像素为单位，内定为2。 width=&quot;500&quot;或width=&quot;70%&quot;：设定线条长度。可以是绝对值（单位是像素）或相对值。如果设置为相对值的话，内定为100%。 color=&quot;#0000FF&quot;：设置线条颜色。 noshade：不要阴影，即设定线条为平面显示。若没有这个属性则表明线条具阴影或立体。 换行标签&lt;br /&gt;如果希望某段文本强制换行显示，就需要使用换行标签。 &lt;div&gt;和&lt;span&gt;标签div的语义是division“分割”； span的语义就是span“范围、跨度”。 div标签：可以把标签中的内容分割为独立的区块。必须单独占据一行。 span标签：和div的作用一致，但不换行。 &lt;span&gt;和&lt;div&gt;唯一的区别在于：&lt;span&gt;是不换行的，而&lt;div&gt;是换行的。 这两个元素是专门为定义CSS样式而生的。DIV+CSS来实现各种样式。 div标签是一个容器级标签，里面什么都能放，甚至可以放div自己。 span也是表达“小区域、小跨度”的标签，但只是一个文本级的标签。就是说，span里面只能放置文字、图片、表单元素。 span里面不能放p、h、ul、dl、ol、div。 div标签的属性： align=&quot;属性值&quot;：设置块儿的位置。属性值可选择：left、right、 center。 注释HTML 注释的格式如下： 1&lt;!-- 我是 html 注释 --&gt; 字体与链接字体标签： &lt;font&gt;、 &lt;b&gt;、 &lt;u&gt; 、&lt;sup&gt; 、&lt;sub&gt; 超链接 &lt;a&gt; 特殊字符（转义字符） &amp;nbsp;：空格 （non-breaking spacing，不断打空格） &amp;lt;：小于号（less than） &amp;gt;：大于号（greater than） &amp;amp;：符号&amp; &amp;quot;：双引号 &amp;apos;：单引号 &amp;copy;：版权© &amp;trade;：商标™ &amp;#32464;：文字绐。其实，#32464是汉字绐的unicode编码。 可以查的。 下划线、中划线、斜体 &lt;u&gt;：下划线标记 &lt;s&gt;或&lt;del&gt;：中划线标记（删除线） &lt;i&gt;或&lt;em&gt;：斜体标记 上标&lt;sup&gt; 下标&lt;sub&gt;上小标这两个标签容易混淆，怎么记呢？这样记：b的意思是bottom：底部 超链接属性： href：目标URL title：悬停文本。 name：主要用于设置一个锚点的名称。 target：告诉浏览器用什么方式来打开目标页面。target属性有以下几个值： _self：在同一个网页中显示（默认值） _blank：在新的窗口中打开。 _parent：在父窗口中显示 _top：在顶级窗口中显示 外部链接12&lt;a href=&quot;页面.html&quot;&gt;点击进入&lt;/a&gt;&lt;a href=&quot;http://www.baidu.com&quot; target=&quot;_blank&quot;&gt;点我点我&lt;/a&gt; a是英语anchor“锚”的意思，是一个文本级的标签，href（hypertext reference）：超文本地址。 锚链接作用是在本页面或者其他页面的的不同位置进行跳转。比如说back-to-top就可以利用锚链接。创建一个锚点，也就是说，使用name属性或者id属性给那个特定的位置起个名字。 123&lt;a name=&quot;anchor1&quot;&gt;top&lt;/a&gt;&lt;a href=&quot;#anchor1&quot;&gt;back-to-top&lt;/a&gt;&lt;a href=&quot;2.html#anchor2&quot;&gt;back-to-top&lt;/a&gt; #回到2.html页面的anchor2锚点 邮件链接没什么用。就是链接写成邮箱，点了弹出邮箱。 图表标签写完这个不写了。 img标签如果要想在网页中显示图像，就可以使用img 标签，它是一个单标签。语法如下： 1&lt;img src=&quot;图片的URL&quot; /&gt; 图片类型 能够插入的图片类型是：jpg(jpeg)、gif、png、bmp等。 不能往网页中插入的图片格式是：psd、ai等。 HTML页面不是直接插入图片，而是插入图片的引用地址，所以要先把图片上传到服务器上。 属性： src属性：指图片的路径。英文名称 source。在写图片的路径时，有两种写法：相对路径、绝对路径。 width：图像的宽度。 height：图像的高度。 alt：当图片不可用（无法显示）的时候，代替图片显示的内容。alt是英语 alternate “替代”的意思，代表替换资源。 title：提示性文本。鼠标悬停时出现的文本。 图片的align属性：图片和周围文字的相对位置。属性取值可以是：bottom（默认）、center、top、left、right。 列表标签列表标签分为三种。 无序列表&lt;ul&gt;无序列表中的每一项是&lt;li&gt;，可以嵌套 无序列表嵌套 >folded123456789101112&lt;ul&gt; &lt;li&gt;&lt;b&gt;北京市&lt;/b&gt; &lt;ul&gt; &lt;li&gt;海淀区&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt;&lt;b&gt;广州市&lt;/b&gt; &lt;ul&gt; &lt;li&gt;天河区&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; 属性：type=&quot;属性值&quot;。属性值可以选： disc(实心原点，默认)，square(实心方点)，circle(空心圆)。 有序列表&lt;ol&gt;差不多，就是有数字序了。 属性：type=&quot;属性值&quot;。属性值可以是：1(阿拉伯数字，默认)、a、A、i、I。结合start属性表示从几开始。 定义列表&lt;dl&gt;&lt;dl&gt;英文单词：definition list，没有属性。dl的子元素只能是dt和dd。 &lt;dt&gt;：definition title 列表的标题，这个标签是必须的 &lt;dd&gt;：definition description 列表的列表项，如果不需要它，可以不加，dd是描述dt的。 定义列表用法非常灵活，可以一个dt配很多dd： dt、dd都是容器级标签，想放什么都可以。 1234567&lt;dl&gt; &lt;dt&gt;购物指南&lt;/dt&gt; &lt;dd&gt; &lt;a href=&quot;#&quot;&gt;购物流程&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;会员介绍&lt;/a&gt; &lt;/dd&gt;&lt;/dl&gt; 表格标签表格标签用&lt;table&gt;表示。一个表格&lt;table&gt;是由每行&lt;tr&gt;组成的，每行是由每个单元格&lt;td&gt;组成的。所以，一个表格是由行组成的（行是由列组成的），而不是由行和列组成的。在以前，要想固定标签的位置，唯一的方法就是表格。现在可以通过CSS定位的功能来实现。 &lt;table&gt;的属性： border：边框。像素为单位。 style=&quot;border-collapse:collapse;&quot;：单元格的线和表格的边框线合并（表格的两边框合并为一条） width：宽度。像素为单位。 height：高度。像素为单位。 bordercolor：表格的边框颜色。 align：表格的水平对齐方式。属性值可以填：left right center。注意：这里不是设置表格里内容的对齐方式，如果想设置内容的对齐方式，要对单元格标签&lt;td&gt;进行设置） cellpadding：单元格内容到边的距离，像素为单位。默认情况下，文字是紧挨着左边那条线的，即默认情况下的值为0。注意不是单元格内容到四条边的距离哈，而是到一条边的距离，默认是与左边那条线的距离。如果设置属性dir=&quot;rtl&quot;，那就指的是内容到右边那条线的距离。 cellspacing：单元格和单元格之间的距离（外边距），像素为单位。默认情况下的值为0 bgcolor=&quot;#99cc66&quot;：表格的背景颜色。 background=&quot;路径src/...&quot;：背景图片。背景图片的优先级大于背景颜色。 bordercolorlight：表格的上、左边框，以及单元格的右、下边框的颜色 bordercolordark：表格的右、下边框，以及单元格的上、左的边框的颜色这两个属性的目的是为了设置3D的效果。 dir：公有属性，单元格内容的排列方式(direction)。 可以 取值：ltr：从左到右（left to right，默认），rtl：从右到左（right to left）既然说dir是共有属性，如果把这个属性放在任意标签中，那表明这个标签的位置可能会从右开始排列。 &lt;tr&gt;：行一个表格就是一行一行组成的。 属性： dir：公有属性，设置这一行单元格内容的排列方式。可以取值： ltr：从左到右（left to right，默认） rtl：从右到左（right to left） bgcolor：设置这一行的单元格的背景色。注：没有background属性，即：无法设置这一行的背景图片，如果非要设置，可以用css实现。 height：一行的高度 align=&quot;center&quot;：一行的内容水平居中显示，取值：left、center、right valign=&quot;center&quot;：一行的内容垂直居中，取值：top、middle、bottom &lt;td&gt;：单元格属性： align：内容的横向对齐方式。属性值可以填：left right center。如果想让每个单元格的内容都居中，这个属性太麻烦了，以后用css来解决。 valign：内容的纵向对齐方式。属性值可以填：top middle bottom width：绝对值或者相对值(%) height：单元格的高度 bgcolor：设置这个单元格的背景色。 background：设置这个单元格的背景图片。 单元格的合并单元格的属性： colspan：横向合并。例如colspan=&quot;2&quot;表示当前单元格在水平方向上要占据两个单元格的位置。 rowspan：纵向合并。例如rowspan=&quot;2&quot;表示当前单元格在垂直方向上要占据两个单元格的位置。 框架标签如果我们希望在一个网页中显示多个页面，那框架标签就派上用场了。frameset和frame已经从 Web标准中删除，建议使用 iframe 代替。 &lt;frameset&gt;以及&lt;frame&gt;内嵌框架内嵌框架用&lt;iframe&gt;表示。&lt;iframe&gt;是&lt;body&gt;的子标记。 内嵌框架inner frame：嵌入在一个页面上的框架(仅仅IE、新版google浏览器支持) 表单标签表单标签用&lt;form&gt;表示，用于与服务器的交互。表单就是收集用户信息的，就是让用户填写的、选择的。 属性： name：表单的名称，用于JS来操作或控制表单时使用； id：表单的名称，用于JS来操作或控制表单时使用； action：指定表单数据的处理程序，一般是PHP，如：action=“login.php” method：表单数据的提交方式，一般取值：get(默认)和post 注意：表单和表格嵌套时，是在&lt;form&gt;标记中套&lt;table&gt;标记。 form标签里面的action属性和method属性，action属性就是表示，表单将提交到哪里。 method属性表示用什么HTTP方法提交，有get、post两种。 有点多，不写了。等我真用到再说。 多媒体标签。。。 废弃标签有很多，是因为html规范一直变化导致的，当然也因为回归本心，html就用于描述语义，很多像样式描述的标签被弃用，想做个集合。算了，不常用的标签都可以视作废弃标签。 元素HTML 元素以开始标签起始，结束标签终止，内容是开始结束之间的内容，某些 元素具有空内容，空元素在开始标签中进行关闭（以开始标签的结束而结束），大多数 HTML 元素可拥有属性。 属性属性可以在元素中添加附加信息，一般描述于开始标签。以名称/值对的形式出现，**比如：name=”value”**。 全局属性全局属性 >folded12345678910111213141516accesskey 设置访问元素的键盘快捷键。class 规定元素的类名（classname）contenteditable 规定是否可编辑元素的内容。contextmenu 指定一个元素的上下文菜单。当用户右击该元素，出现上下文菜单data-* 用于存储页面的自定义数据dir 设置元素中内容的文本方向。draggable 指定某个元素是否可以拖动dropzone 指定是否将数据复制，移动，或链接，或删除hidden hidden 属性规定对元素进行隐藏。id 规定元素的唯一 idlang 设置元素中内容的语言代码。spellcheck 检测元素是否拼写错误style 规定元素的行内样式（inline style）tabindex 设置元素的 Tab 键控制次序。title 规定元素的额外信息（可在工具提示中显示）translate 指定是否一个元素的值在页面载入时是否需要翻译 不想写了，要用再查吧。","link":"/2019/10/09/HTML%E7%AC%94%E8%AE%B0/"},{"title":"Hexo-icarus主题黑夜模式以及背景","text":"对主题增改代码实现夜间模式，以及模式切换。夜间模式增加使用canvas绘图的背景。 对更新时需要备份的代码文件作记录（大改过的都要）。 因为我不会写前端（我不会写代码，我是弱智），写得很烂（这玩意标准怎么乱七八糟的），东拼西凑 Ctrl+CV 整好了，为了避免下次更新把这一块更挂掉，所以都得记录下来。 修改icarus 也可能是 node_modules/hexo-theme-icarus 文件夹 在 icarus/source/js 下增加 night.js 在 icarus/source/css 下增加 night.styl 在 icarus/source/css 下修改 default.styl ，末尾新增一行 @import 'night' 在 icarus/layout/common 下修改 scripts.jsx 在 &lt;Fragment&gt; 标签间添加 &lt;script&gt; 标签索引 1&lt;script src={url_for('/js/night.js')} defer={true}&gt;&lt;/script&gt; 在icarus/layout/common 下修改 navbar.jsx 与 footer.jsx 大改的见下代码增改各分段的代码。 代码增改night.jsnight.js >folded12345678910111213141516171819202122232425262728293031323334(function() { var isNight = localStorage.getItem('night'); var nightNav; function applyNight(value) { if (value.toString() === 'true') { document.body.classList.remove('light'); document.body.classList.add('night'); } else { document.body.classList.remove('night'); document.body.classList.add('light'); } } function findNightNav() { nightNav = document.getElementById('night-nav'); if (!nightNav) { setTimeout(findNightNav, 100); } else { nightNav.addEventListener('click', switchNight); } } function switchNight() { isNight = isNight ? isNight.toString() !== 'true' : true; applyNight(isNight); localStorage.setItem('night', isNight); } findNightNav(); isNight &amp;&amp; applyNight(isNight);}()); night.stylnight.styl >folded123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268dark-primary-color = rgb(55, 61, 72)dark-primary-color-hover = rgb(67, 74, 86)dark-primary-color-active = rgb(44, 49, 58)dark-font-color = #c0c0c0#universe display: none.navbar-logo,.footer-logo .logo-img-dark display: nonenight() background: #0e1225 // code highlight (https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-dark.min.css) .hljs{display:block;overflow-x:auto;padding:0.5em;color:#abb2bf;background:#282c34}.hljs-comment,.hljs-quote{color:#5c6370;font-style:italic}.hljs-doctag,.hljs-keyword,.hljs-formula{color:#c678dd}.hljs-section,.hljs-name,.hljs-selector-tag,.hljs-deletion,.hljs-subst{color:#e06c75}.hljs-literal{color:#56b6c2}.hljs-string,.hljs-regexp,.hljs-addition,.hljs-attribute,.hljs-meta-string{color:#98c379}.hljs-built_in,.hljs-class .hljs-title{color:#e6c07b}.hljs-attr,.hljs-variable,.hljs-template-variable,.hljs-type,.hljs-selector-class,.hljs-selector-attr,.hljs-selector-pseudo,.hljs-number{color:#d19a66}.hljs-symbol,.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-title{color:#61aeee}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:bold}.hljs-link{text-decoration:underline} .content code color: rgb(203,186,125) // night icon changed to fas fa-sun #night-nav #night-icon:before content: '\\f185' // global background #universe background: radial-gradient(1600px at 70% 120%, #212750 10%, #020409 100%) display: block position: fixed margin: 0 padding: 0 border: 0 outline: 0 left: 0 top: 0 width: 100% height: 100% pointer-events: none // global brightness img, video, iframe, .waifu, .donate filter: brightness(0.8) -webkit-filter: brightness(0.8) // logo .navbar-logo, .footer-logo .logo-img display: none .logo-img-dark display: inline-block // navigation bar, cards .navbar-main .navbar-menu .navbar-item &amp;:hover, &amp;:focus color: #ffffff background-color: dark-primary-color .navbar, .card background-color: rgba(40,44,52,0.5) backdrop-filter: none -webkit-backdrop-filter: none .card &amp;:hover background-color: rgba(40,44,52,0.8) .footer backdrop-filter: none -webkit-backdrop-filter: none &amp;:before background-color: rgba(40,44,52,0.5) // input .input, .textarea background-color: dark-primary-color-hover border-color: dark-primary-color // button .button.is-primary, .button.is-light, .button.is-small background-color: dark-primary-color color: dark-font-color &amp;:hover, &amp;.is-hovered color: #ffffff background-color: dark-primary-color-hover &amp;:active, &amp;.is-active color: #ffffff background-color: dark-primary-color-active .button.is-white, .button.is-transparent background-color: transparent &amp;:hover background-color: dark-primary-color !important .pagination .pagination-next, .pagination .pagination-previous .pagination-link:not(.is-current) color: dark-font-color background-color: dark-primary-color a color: dark-font-color .pagination-link.is-current background-color: dark-primary-color-hover border-color: dark-primary-color-hover // comment .v .vwrap, .v .vwrap .vheader .vinput border-color: dark-primary-color .v .vwrap .vheader .vinput:focus border-color: dark-primary-color-hover .v .vbtn color: dark-font-color background-color: dark-primary-color border-color: dark-primary-color &amp;:hover background-color: dark-primary-color-hover &amp;:active background-color: dark-primary-color-active .v .vlist .vcard .vhead .vsys background-color: dark-primary-color .v a:hover, .v .vlist .vcard .vh .vmeta .vat color: #ffffff .v .vlist .vcard .vcontent.expand:before background: -webkit-gradient(linear,left top,left bottom,from(rgba(37,41,54,0)),to(rgba(37,41,54,1))) background: linear-gradient(180deg,rgba(37,41,54,0),rgba(37,41,54,1)) .v .vlist .vcard .vcontent.expand:after background: rgba(37,41,54,1) .v .vlist .vcard .vh, .v .vlist .vcard .vquote border-color: dark-primary-color-hover .v code, .v pre background-color: transparent // font color body, strong, time, .title, .footer, .card, .content h1, .content h2, .content h3, .content h4, .content h5, .content h6, .navbar-item, .navbar-item.is-active, .navbar-link, .menu-list a, .menu-label, .level-item, .input, .textarea, .button.is-white, .button.is-transparent, .article-licensing, .v * color: dark-font-color .media-content, .has-text-grey, .link-muted color: dark-font-color !important a color: rgb(82, 153, 224) &amp;:hover color: #ffffff .timeline a, [data-type=&quot;recent-posts&quot;] a color: dark-font-color &amp;:hover color: #ffffff // quote .content blockquote, .article-licensing background-color: dark-primary-color border-color: dark-primary-color-hover // table .content table thead td, .content table thead th color: dark-font-color .content table td, .content table th border-color: dark-primary-color-hover // break line hr background-color: dark-primary-color-hover // tags and menus article.article, article.media .title a background-image: linear-gradient(transparent calc(100% - 1px), dark-font-color 1px) .title:hover a // override anotherr !important color: dark-font-color !important .tag:not(body) color: dark-font-color background-color: dark-primary-color .widget .tags .tag:first-child, .tag.is-grey background-color: dark-primary-color-hover .menu-list a:hover background-color: dark-primary-color .menu-list a.is-active background-color: dark-primary-color-hover .menu-list li ul border-color: dark-primary-color // time line .timeline .media:last-child:after background-color: rgb(37,41,54) .timeline border-color: dark-primary-color-hover .timeline .media:before background-color: dark-primary-color-hover // search box .searchbox .searchbox-container, .searchbox-header, .searchbox-header .searchbox-input, .searchbox-header .searchbox-close, .searchbox-body, .searchbox-result-section, .searchbox-result-item color: dark-font-color background-color: dark-primary-color border-color: dark-primary-color-hover .searchbox-container .searchbox-result-section .searchbox-result-item:hover, .searchbox-container .searchbox-result-section .searchbox-result-item.active, .searchbox-container .searchbox-header .searchbox-close:hover color: #ffffff background-color: dark-primary-color-hover // selection ::selection color: #ffffff background-color: rgba(52,109,167,0.8) ::-moz-selection color: #ffffff background-color: rgba(52,109,167,0.8) input:-webkit-autofill -webkit-text-fill-color: dark-font-color !important box-shadow: 0 0 0px 1000px dark-primary-color inset // twikoo .twikoo pre background-color: dark-primary-color code color: rgb(203,186,125) background-color: dark-primary-colorbody.night night()@media (prefers-color-scheme: dark) body:not(.light) night() navbar &amp; footer.jsx对 navbar.jsx 和 footer.jsx 的修改差不多 添加logo的两种模式，主题配置处也要相应改变为logo: logo.light 和 logo.dark 两个分项 render(){const} 下将 logoUrl 改为 logoLightUrl，logoDarkUrl。 let navbarLogo ='' 的第一个 else 添加 1234navbarLogo = [ &lt;img class=&quot;logo-img&quot; src={logoLightUrl} alt={siteTitle} height=&quot;28&quot; /&gt;, &lt;img class=&quot;logo-img-dark&quot; src={logoDarkUrl} alt={siteTitle} height=&quot;28&quot; /&gt; ]; 在 return 标签内，{showtoc} 前添加黑夜切换图标的链接，切回白天的图标在 night.styl 里设置，图标都是用的 fontawesome-icon-免费图标。 123&lt;a class=&quot;navbar-item night&quot; id=&quot;night-nav&quot; title=&quot;Night Mode&quot; href=&quot;javascript:;&quot;&gt; &lt;i class=&quot;fas fa-moon&quot; id=&quot;night-icon&quot;&gt;&lt;/i&gt;&lt;/a&gt; module.exports 添加 12const logoLight = logo instanceof String ? logo : logo.lightconst logoDark = logo instanceof String ? logo : logo.dark return 修改 logoUrl 为 12logoLightUrl: url_for(logoLight),logoDarkUrl: url_for(logoDark), 添加夜空流星背景 在 icarus/source/js 下增加 universe.js universe.js >folded123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157/** * created by lvfan * 2018-09-04 */(function drawBg() { window.requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame; // const var starDensity = 0.216; var speedCoeff = 0.05; var canva = document.getElementById('universe'); // let var width; var height; var starCount; /* no-unused-vars */ // var circleRadius; // var circleCenter; var first = true; var giantColor = '180,184,240'; var starColor = '226,225,142'; var cometColor = '226,225,224'; var stars = []; var universe; windowResizeHandler(); window.addEventListener('resize', windowResizeHandler, false); function windowResizeHandler() { width = window.innerWidth; height = window.innerHeight; starCount = width * starDensity; // circleRadius = (width &gt; height ? height / 2 : width / 2); // circleCenter = { // x: width / 2, // y: height / 2 // }; canva.setAttribute('width', width); canva.setAttribute('height', height); } createUniverse(); function createUniverse() { universe = canva.getContext('2d'); for (var i = 0; i &lt; starCount; i++) { stars[i] = new Star(); stars[i].reset(); } draw(); } function draw() { universe.clearRect(0, 0, width, height); var starsLength = stars.length; for (var i = 0; i &lt; starsLength; i++) { var star = stars[i]; star.move(); star.fadeIn(); star.fadeOut(); star.draw(); } } function Star() { this.reset = function () { this.giant = getProbability(3); this.comet = this.giant || first ? false : getProbability(10); this.x = getRandInterval(0, width - 10); this.y = getRandInterval(0, height); this.r = getRandInterval(1.1, 2.6); this.dx = getRandInterval(speedCoeff, 6 * speedCoeff) + (this.comet + 1 - 1) * speedCoeff * getRandInterval(50, 120) + speedCoeff * 2; this.dy = -getRandInterval(speedCoeff, 6 * speedCoeff) - (this.comet + 1 - 1) * speedCoeff * getRandInterval(50, 120); this.fadingOut = null; this.fadingIn = true; this.opacity = 0; this.opacityTresh = getRandInterval(0.2, 1 - (this.comet + 1 - 1) * 0.4); this.do = getRandInterval(0.0005, 0.002) + (this.comet + 1 - 1) * 0.001; }; this.fadeIn = function () { if (this.fadingIn) { this.fadingIn = !(this.opacity &gt; this.opacityTresh); this.opacity += this.do; } }; this.fadeOut = function () { if (this.fadingOut) { this.fadingOut = !(this.opacity &lt; 0); this.opacity -= this.do / 2; if (this.x &gt; width || this.y &lt; 0) { this.fadingOut = false; this.reset(); } } }; this.draw = function () { universe.beginPath(); if (this.giant) { universe.fillStyle = 'rgba(' + giantColor + ',' + this.opacity + ')'; universe.arc(this.x, this.y, 2, 0, 2 * Math.PI, false); } else if (this.comet) { universe.fillStyle = 'rgba(' + cometColor + ',' + this.opacity + ')'; universe.arc(this.x, this.y, 1.5, 0, 2 * Math.PI, false); // comet tail for (var i = 0; i &lt; 30; i++) { universe.fillStyle = 'rgba(' + cometColor + ',' + (this.opacity - (this.opacity / 20) * i) + ')'; universe.rect(this.x - this.dx / 4 * i, this.y - this.dy / 4 * i - 2, 2, 2); universe.fill(); } } else { universe.fillStyle = 'rgba(' + starColor + ',' + this.opacity + ')'; universe.rect(this.x, this.y, this.r, this.r); } universe.closePath(); universe.fill(); }; this.move = function () { this.x += this.dx; this.y += this.dy; if (this.fadingOut === false) { this.reset(); } if (this.x &gt; width - (width / 4) || this.y &lt; 0) { this.fadingOut = true; } }; (function () { setTimeout(function () { first = false; }, 50); })(); } function getProbability(percents) { return ((Math.floor(Math.random() * 1000) + 1) &lt; percents * 10); } function getRandInterval(min, max) { return (Math.random() * (max - min) + min); } /* --------------------------------- * www.imaegoo.com * NO DRAW IN LIGHT MODE * --------------------------------- */ (function imaegoo () { if (document.body.classList.contains('night')) { draw(); } window.requestAnimationFrame(imaegoo); })();}()); 修改 layout/layout.jsx ，添加canvas 和星空绘图的script 路径 12345678&lt;body class={}&gt; &lt;script ......&gt;&lt;/script&gt; &lt;canvas id=&quot;universe&quot;&gt;&lt;/canvas&gt; ... ... ... &lt;script type=&quot;text/javascript&quot; src=&quot;/js/universe.js&quot;&gt;&lt;/script&gt;&lt;/body&gt; 添加日间模式背景方案有几种，我选最懒的改最少代码的。由于是日间模式的背景图片，而 navbar 和 footer 的透明度不是100%（懒得改了），所以背景尽量是上下白色的比较合适，同时不要太大，影响加载，随便挑一张。 图片塞进 icarus\\theme\\source\\img 里。 修改 icarus\\source\\css icarus\\include\\style\\base.style 反正 body 的样式在哪就修改哪里。 12345body /*添加下列代码*/ background: url(../img/mount.jpg) no-repeat background-attachment: fixed background-size: cover 随便写一个不包括上级目录的路径，发现返回 404 not found /css/path/background.jpg ，说明索引目录在 icarus\\source\\css ，照着写相对路径即可。 background的属性主要要写好 url 图片路径（网络路径也可以，API也可以）， attachment 是否滚动：fixed 不滚动，scoll 滚动， size 图像的大小：原始尺寸 auto ，覆盖容器 cover ，拉伸以显示全图 contain 等， 如果图片够大，什么 position ，clip 都可以不管了，适配需要的话再查，添加即可。 备份列表但我好像已经都 git 到 github 的私有仓库上了。 icarus\\source\\js\\night.js icarus\\source\\css\\night.styl icarus\\layout\\common\\navbar.jsx icarus\\layout\\common\\footer.jsx icarus\\source\\js\\universe.js icarus\\theme\\source\\img 参考cdnjs-开源前端库文件：https://cdnjs.com/ highlight.js-代码块样式：https://highlightjs.org/ fontawesome-icon-免费图标：https://fontawesome.com/icons icarus夜间主题配置：http://blog.sbx0.cn/2020/04/07/icarus-3-night-mode/ icarus 4 配置夜间模式：https://blog.asahih.com/hexo-icarus-night-mode/ support night dark mode：https://github.com/ppoffice/hexo-theme-icarus/issues/564 hexo-theme-icarus 3 食用经验分享：https://www.imaegoo.com/2020/icarus-3-guide/ 如何给 Icarus 增加夜间模式：https://www.imaegoo.com/2019/icarus-night-mode-2/ icarus-一个hexo主题美化过程：https://purplezi.gitee.io/2021/01/15/icarus/ icarus-github-issues主题背景 #612：https://github.com/ppoffice/hexo-theme-icarus/issues/612 W3Schools-background：https://www.w3schools.com/css/css_background.asp W3Schools-background-properties：https://www.w3schools.com/cssref/css3_pr_background.asp","link":"/2021/09/14/Hexo-icarus%E4%B8%BB%E9%A2%98%E9%BB%91%E5%A4%9C%E6%A8%A1%E5%BC%8F%E4%BB%A5%E5%8F%8A%E8%83%8C%E6%99%AF/"},{"title":"Hexo进阶使用","text":"这是一篇对hexo以及typora等博客工具的食用说明手册，随时补充。 总览​ hexo静态博客，简洁大气，个人比较中意。typora作为轻量级的markdown编辑器，界面也比较简洁，当然在支持上不够完全。导致了一些markdown语法的页面渲染与本地有所区别，特此记录。​ 也可以考虑换个大型的编辑器？ Hexohexo插件​ hexo插件比较丰富，可以在官方插件页下载使用插件。 hexo-filter-flowchat渲染flow图， hexo-filter-mermaid-diagrams渲染mermaid和diagrams， hexo-filter-sequence渲染序列图， live2d-widget看板娘，没啥用，还有可能挡住内容和按钮，减慢加载速度。 hexo-bilibili-card插入哔哩哔哩视频卡片具体有没用，好不好用有待测试。 hexo-blog-encrypt文章加密，确实可以加密，但是解密之后好像样式会崩。 hexo标签​ hexo使用标签语言可以实现丰富页面的媒体展示。hexo官方标签插件介绍，不能嵌入到markdown语法中。 quote引用 quote123{% blockquote [author[, source]] [link] [source_link_title] %}content{% endblockquote %} 俱往矣，数风流人物，还看今朝 毛泽东沁园春·雪 code block代码块 code12345678{% codeblock [title] [lang:language] [url] [link text] [additional options] %}{% codeblock action_logic.vhd lang:vhdl https://github.com/scutLMG/pixels_plane-VHDL %}library IEEE;use IEEE.STD_LOGIC_1164.ALL;use IEEE.STD_LOGIC_ARITH.ALL;use IEEE.STD_LOGIC_UNSIGNED.ALL;{% endcodeblock %} action_logic.vhdpixels_plane-VHDL1234library IEEE;use IEEE.STD_LOGIC_1164.ALL;use IEEE.STD_LOGIC_ARITH.ALL;use IEEE.STD_LOGIC_UNSIGNED.ALL; 和markdown语法的区别在于可以添加标题和链接及其名字。markdown语法中强行写入标题，会导致编辑器中无法识别并分配上色方案，但是hexo网页渲染是没问题的，所以其实区别不大。 YouTube视频 youtube1{% youtube video_id [type] [cookie] %} img图片 img1{% img [class names] /path/to/image [width] [height] '&quot;title text&quot; &quot;alt text&quot;' %} title text为悬停显示名称，alt text为图像标题。图片路径的名称不要带空格，特别是像通过批量重命名的图片，名称就有空格，往往无法显示。 link链接 link1{% link text url [external] [title] %} 博客加入了链接，不如`markdown`自带的方便好用。 ​ 摘要 在markdown文件中使用&lt;!--more--&gt;可以将其之上的文字划分为摘要，在主页时，文章只显示摘要和阅读更多按钮。 ​ hexo命令hexo clean 清除旧的缓存，source文件夹中的文件不会被清除。 hexo g生成博客 hexo s本地运行博客预览，可以进行实时的样式、文章修改（当然了，还是要刷新的） hexo d上传到github hexo new page page_name生成新页面时使用，生成后要在配置文件内添加导航分栏，自定义渲染以及布局文件。 ​ Front-matter​ front-matter似乎是属于yaml的一种书写方式。写在.md文件的头部，定义其表现形式，使用三重虚线包围 Front Matter，Hexo-Front-matter，一般就下面几个参数。 参数 描述 默认值 layout 布局 config.default_layout title 标题 文章的文件名 date 建立日期 文件建立日期 updated 更新日期 文件更新日期 comments 开启文章的评论功能 true tags 标签（不适用于分页） categories 分类（不适用于分页） 其他​ Typora主要是markdown语法和Typora的显示兼容。 Markdown语法已经很熟练了，而且编辑器大部分都很友好，懒得写了。可查询网页markdown指南中文版，以及Typora支持，有不太熟悉的再写到下面。 插入空行使用：TAB+空格，&lt;/br&gt;标签等等。 ​ 其他的待补充。 Bulma一种css框架。 按钮 Info Success Warning Danger 123456&lt;div class=&quot;buttons&quot;&gt; &lt;button class=&quot;button is-info&quot;&gt;Info&lt;/button&gt; &lt;button class=&quot;button is-success&quot;&gt;Success&lt;/button&gt; &lt;button class=&quot;button is-warning&quot;&gt;Warning&lt;/button&gt; &lt;button class=&quot;button is-danger&quot;&gt;Danger&lt;/button&gt;&lt;/div&gt; 光有按钮肯定是不行的，一般我们还需要给按钮增加事件，比如点击下面的按钮，可以显示一条一言（Hitokoto）。 显示一言 ↑↑↑ 试着点击“显示一言”！ function showHitokoto (event) { event.target.classList.add('is-loading'); $.ajax({ type: 'GET', url: 'https://v1.hitokoto.cn/', success: function (data) { $('.hitokoto').text(data.hitokoto); event.target.classList.remove('is-loading'); } }); } 12345678910111213141516&lt;button class=&quot;button is-info&quot; onclick=&quot;showHitokoto(event)&quot;&gt;显示一言&lt;/button&gt;&lt;blockquote class=&quot;hitokoto&quot;&gt;↑↑↑ 试着点击“显示一言”！&lt;/blockquote&gt;&lt;script&gt;function showHitokoto (event) { event.target.classList.add('is-loading'); $.ajax({ type: 'GET', url: 'https://v1.hitokoto.cn/', success: function (data) { $('.hitokoto').text(data.hitokoto); event.target.classList.remove('is-loading'); } });}&lt;/script&gt; 进度条 12345&lt;progress class=&quot;progress is-info&quot; value=&quot;20&quot; max=&quot;100&quot;&gt;&lt;/progress&gt;&lt;progress class=&quot;progress is-success&quot; value=&quot;40&quot; max=&quot;100&quot;&gt;&lt;/progress&gt;&lt;progress class=&quot;progress is-warning&quot; value=&quot;60&quot; max=&quot;100&quot;&gt;&lt;/progress&gt;&lt;progress class=&quot;progress is-danger&quot; value=&quot;80&quot; max=&quot;100&quot;&gt;&lt;/progress&gt;&lt;progress class=&quot;progress is-info&quot; max=&quot;100&quot;&gt;&lt;/progress&gt; 标签页 Pictures Music Videos Documents Pixabay 是全球知名的图库网站及充满活力的创意社区,拥有上百万张免费正版高清照片素材,涵盖风景、人物、动态、静物等多种分类,你可以在任何地方使用 Pixabay 图库中的素材… 网易云音乐 是一款专注于发现与分享的音乐产品,依托专业音乐人、DJ、好友推荐及社交功能,为用户打造全新的音乐生活。 哔哩哔哩 是国内知名的视频弹幕网站,这里有最及时的动漫新番,最棒的ACG氛围,最有创意的Up主。大家可以在这里找到许多欢乐。 石墨文档 是全新一代云 Office 办公软件,支持多人在线协作编辑文档和表格,独有内容级安全,全过程留痕可追溯。PC 端和移动端全覆盖,随时随地远程办公。即写即存… .content .tabs ul { margin: 0; } .tab-content { display: none; } function onTabClick (event) { var tabTitle = $(event.currentTarget).children('span:last-child').text(); $('.article .content .tab-content').css('display', 'none'); $('.article .content .tabs li').removeClass('is-active'); $('#' + tabTitle).css('display', 'block'); $(event.currentTarget).parent().addClass('is-active'); } 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;div class=&quot;tabs is-toggle&quot;&gt;&lt;ul&gt;&lt;li class=&quot;is-active&quot;&gt;&lt;a onclick=&quot;onTabClick(event)&quot;&gt;&lt;span class=&quot;icon is-small&quot;&gt;&lt;i class=&quot;fas fa-image&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;span&gt;Pictures&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a onclick=&quot;onTabClick(event)&quot;&gt;&lt;span class=&quot;icon is-small&quot;&gt;&lt;i class=&quot;fas fa-music&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;span&gt;Music&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a onclick=&quot;onTabClick(event)&quot;&gt;&lt;span class=&quot;icon is-small&quot;&gt;&lt;i class=&quot;fas fa-film&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;span&gt;Videos&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a onclick=&quot;onTabClick(event)&quot;&gt;&lt;span class=&quot;icon is-small&quot;&gt;&lt;i class=&quot;far fa-file-alt&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;span&gt;Documents&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;{% raw %}&lt;div id=&quot;Pictures&quot; class=&quot;tab-content&quot; style=&quot;display: block;&quot;&gt;{% endraw %}[Pixabay](https://pixabay.com/zh/) 是全球知名的图库网站及充满活力的创意社区,拥有上百万张免费正版高清照片素材,涵盖风景、人物、动态、静物等多种分类,你可以在任何地方使用 Pixabay 图库中的素材...{% raw %}&lt;/div&gt;{% endraw %}{% raw %}&lt;div id=&quot;Music&quot; class=&quot;tab-content&quot;&gt;{% endraw %}[网易云音乐](https://music.163.com/) 是一款专注于发现与分享的音乐产品,依托专业音乐人、DJ、好友推荐及社交功能,为用户打造全新的音乐生活。{% raw %}&lt;/div&gt;{% endraw %}{% raw %}&lt;div id=&quot;Videos&quot; class=&quot;tab-content&quot;&gt;{% endraw %}[哔哩哔哩](https://www.bilibili.com/) 是国内知名的视频弹幕网站,这里有最及时的动漫新番,最棒的ACG氛围,最有创意的Up主。大家可以在这里找到许多欢乐。{% raw %}&lt;/div&gt;{% endraw %}{% raw %}&lt;div id=&quot;Documents&quot; class=&quot;tab-content&quot;&gt;{% endraw %}[石墨文档](https://shimo.im/) 是全新一代云 Office 办公软件,支持多人在线协作编辑文档和表格,独有内容级安全,全过程留痕可追溯。PC 端和移动端全覆盖,随时随地远程办公。即写即存...{% raw %}&lt;/div&gt;{% endraw %}&lt;style type=&quot;text/css&quot;&gt;.content .tabs ul { margin: 0; }.tab-content { display: none; }&lt;/style&gt;&lt;script&gt;function onTabClick (event) { var tabTitle = $(event.currentTarget).children('span:last-child').text(); $('.article .content .tab-content').css('display', 'none'); $('.article .content .tabs li').removeClass('is-active'); $('#' + tabTitle).css('display', 'block'); $(event.currentTarget).parent().addClass('is-active');}&lt;/script&gt; 彩色突出 Icarus 主题以白色的简洁为主，但有时候我们希望在文章中用特别的样式注明一些内容，markdown 语法就不够用了，所以在此分享一下我的高级玩法。 123{% raw %}&lt;div class=&quot;notification is-info&quot;&gt;{% endraw %}[Icarus](https://ppoffice.github.io/hexo-theme-icarus//) 主题以白色的简洁为主，但有时候我们希望在文章中用**特别的样式**注明一些内容，*markdown* 语法就不够用了，所以在此分享一下我的高级玩法。{% raw %}&lt;/div&gt;{% endraw %} Icarus 主题以白色的简洁为主，但有时候我们希望在文章中用特别的样式注明一些内容，markdown 语法就不够用了，所以在此分享一下我的高级玩法。 123{% raw %}&lt;div class=&quot;notification is-success&quot;&gt;{% endraw %}[Icarus](https://ppoffice.github.io/hexo-theme-icarus/) 主题以白色的简洁为主，但有时候我们希望在文章中用**特别的样式**注明一些内容，*markdown* 语法就不够用了，所以在此分享一下我的高级玩法。{% raw %}&lt;/div&gt;{% endraw %} Icarus 主题以白色的简洁为主，但有时候我们希望在文章中用特别的样式注明一些内容，markdown 语法就不够用了，所以在此分享一下我的高级玩法。 123{% raw %}&lt;div class=&quot;notification is-warning&quot;&gt;{% endraw %}[Icarus](https://ppoffice.github.io/hexo-theme-icarus/) 主题以白色的简洁为主，但有时候我们希望在文章中用**特别的样式**注明一些内容，*markdown* 语法就不够用了，所以在此分享一下我的高级玩法。{% raw %}&lt;/div&gt;{% endraw %} Icarus 主题以白色的简洁为主，但有时候我们希望在文章中用特别的样式注明一些内容，markdown 语法就不够用了，所以在此分享一下我的高级玩法。 123{% raw %}&lt;div class=&quot;notification is-danger&quot;&gt;{% endraw %}[Icarus](https://ppoffice.github.io/hexo-theme-icarus/) 主题以白色的简洁为主，但有时候我们希望在文章中用**特别的样式**注明一些内容，*markdown* 语法就不够用了，所以在此分享一下我的高级玩法。{% raw %}&lt;/div&gt;{% endraw %} Icarus 主题以白色的简洁为主，但有时候我们希望在文章中用特别的样式注明一些内容，markdown 语法就不够用了，所以在此分享一下我的高级玩法。 123{% raw %}&lt;article class=&quot;message is-info&quot;&gt;&lt;div class=&quot;message-body&quot;&gt;{% endraw %}[Icarus](https://ppoffice.github.io/hexo-theme-icarus/) 主题以白色的简洁为主，但有时候我们希望在文章中用**特别的样式**注明一些内容，*markdown* 语法就不够用了，所以在此分享一下我的高级玩法。{% raw %}&lt;/div&gt;&lt;/article&gt;{% endraw %} Icarus 主题以白色的简洁为主，但有时候我们希望在文章中用特别的样式注明一些内容，markdown 语法就不够用了，所以在此分享一下我的高级玩法。 123{% raw %}&lt;article class=&quot;message is-success&quot;&gt;&lt;div class=&quot;message-body&quot;&gt;{% endraw %}[Icarus](https://ppoffice.github.io/hexo-theme-icarus/) 主题以白色的简洁为主，但有时候我们希望在文章中用**特别的样式**注明一些内容，*markdown* 语法就不够用了，所以在此分享一下我的高级玩法。{% raw %}&lt;/div&gt;&lt;/article&gt;{% endraw %} Icarus 主题以白色的简洁为主，但有时候我们希望在文章中用特别的样式注明一些内容，markdown 语法就不够用了，所以在此分享一下我的高级玩法。 123{% raw %}&lt;article class=&quot;message is-warning&quot;&gt;&lt;div class=&quot;message-body&quot;&gt;{% endraw %}[Icarus](https://ppoffice.github.io/hexo-theme-icarus/) 主题以白色的简洁为主，但有时候我们希望在文章中用**特别的样式**注明一些内容，*markdown* 语法就不够用了，所以在此分享一下我的高级玩法。{% raw %}&lt;/div&gt;&lt;/article&gt;{% endraw %} Icarus 主题以白色的简洁为主，但有时候我们希望在文章中用特别的样式注明一些内容，markdown 语法就不够用了，所以在此分享一下我的高级玩法。 123{% raw %}&lt;article class=&quot;message is-danger&quot;&gt;&lt;div class=&quot;message-body&quot;&gt;{% endraw %}[Icarus](https://ppoffice.github.io/hexo-theme-icarus/) 主题以白色的简洁为主，但有时候我们希望在文章中用**特别的样式**注明一些内容，*markdown* 语法就不够用了，所以在此分享一下我的高级玩法。{% raw %}&lt;/div&gt;&lt;/article&gt;{% endraw %} 活用 Bulma 美化 Icarus 文章 Icarus 主题以白色的简洁为主，但有时候我们希望在文章中用特别的样式注明一些内容，markdown 语法就不够用了，所以在此分享一下我的高级玩法。 12345{% raw %}&lt;article class=&quot;message is-info&quot;&gt;&lt;div class=&quot;message-header&quot;&gt;{% endraw %}活用 Bulma 美化 Icarus 文章{% raw %}&lt;/div&gt;&lt;div class=&quot;message-body&quot;&gt;{% endraw %}[Icarus](https://ppoffice.github.io/hexo-theme-icarus/) 主题以白色的简洁为主，但有时候我们希望在文章中用**特别的样式**注明一些内容，*markdown* 语法就不够用了，所以在此分享一下我的高级玩法。{% raw %}&lt;/div&gt;&lt;/article&gt;{% endraw %} 让简介不出现在正文我们知道 Hexo 用 &lt;!-- more --&gt; 可以分隔简介和正文部分，但这样简介也会在正文中出现，如果我们不想让简介部分出现在正文呢？ 这里的内容只会出现在 简介 .post-summary { display: none; } 这里的内容只会出现在 正文 12345678910111213{% raw %}&lt;div class=&quot;post-summary&quot;&gt;{% endraw %}这里的内容只会出现在 **简介**{% raw %}&lt;/div&gt;{% endraw %}&lt;!-- more --&gt;&lt;style type=&quot;text/css&quot;&gt;.post-summary { display: none; }&lt;/style&gt;这里的内容只会出现在 **正文** 封面图来源声明 &nbsp;&nbsp; Vector Landscape Vectors by Vecteezy 1234&lt;a class=&quot;tag is-dark is-medium&quot; href=&quot;https://www.vecteezy.com/free-vector/vector-landscape&quot; target=&quot;_blank&quot;&gt;&lt;span class=&quot;icon&quot;&gt;&lt;i class=&quot;fas fa-camera&quot;&gt;&lt;/i&gt;&lt;/span&gt;&amp;nbsp;&amp;nbsp;Vector Landscape Vectors by Vecteezy&lt;/a&gt; 这就是关于 Icarus 的高级玩法了。懒得写了，复制imaegoo的，似乎在typora中，不能即时显示渲染情况。","link":"/2020/07/14/Hexo%E8%BF%9B%E9%98%B6%E4%BD%BF%E7%94%A8/"},{"title":"CSS笔记","text":"CSS的学习记录。 样式属性，学个大致框架，要用还得查，用集成的css框架比较好。比如bootstrap什么的。 CSS单位绝对：in、cm、mm、pt、pc 相对：px、em：印刷单位，相当于12个点、% 一般用px得了。懒。 CSS语法键值对。选择器{k: v; k: v;} 注释/*xxxx*/写在&lt;style&gt;&lt;/style&gt;里 CSS属性以下属性值中，括号中的内容表示 sublime 中的快捷键。 字体颜色：（c） 1color:red; color 属性的值，可以是英语单词，比如 red、blue、yellow 等等；也可以是 rgb、十六进制(后期详细讲)。 字号大小：（fos） 1font-size:40px; font 就是“字体”，size 就是“尺寸”。px 是“像素”。单位必须加，不加不行。 背景颜色：（bgc） 1background-color: blue; background 就是“背景”。 加粗：（fwb） 1font-weight: bold; font 是“字体” weight 是“重量”的意思，bold 粗。 不加粗：（fwn） 1font-weight: normal; normal 就是正常的意思。 斜体：（fsi） 1font-style: italic; italic 就是“斜体”。 不斜体：（fsn） 1font-style: normal; 下划线：（tdu） 1text-decoration: underline; decoration 就是“装饰”的意思。 没有下划线：（tdn） 1text-decoration:none; 定位属性CSS的定位属性有三种，分别是绝对定位、相对定位、固定定位。 position: absolute; &lt;!-- 绝对定位 --&gt; position: relative; &lt;!-- 相对定位 --&gt; position: fixed; &lt;!-- 固定定位 --&gt; 相对定位相对定位：让元素相对于自己原来的位置，进行位置调整（可用于盒子的位置微调）。 背景属性中，是通过如下格式： 1background-position:向右偏移量 向下偏移量; 相对定位属性，是通过如下格式： 123position: relative;left: 50px;top: 50px; 相对定位的举例： 12345678910111213141516171819202122232425&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; .div1{ width: 200px; height: 200px; border: 1px solid red; } .div2{ position: relative;/*相对定位：相对于自己原来的位置*/ left: 50px;/*横坐标：正值表示向右偏移，负值表示向左偏移*/ top: 50px;/*纵坐标：正值表示向下偏移，负值表示向上偏移*/ width: 200px; height: 200px; border: 1px solid red; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;div1&quot;&gt;有生之年&lt;/div&gt; &lt;div class=&quot;div2&quot;&gt;狭路相逢&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 相对定位不脱标相对定位：不脱标，老家留坑，别人不会把它的位置挤走。 也就是说，相对定位的真实位置还在老家，只不过影子出去了，可以到处飘。 相对定位的用途如果想做“压盖”效果（把一个div放到另一个div之上），我们一般不用相对定位来做。相对定位，就两个作用： （1）微调元素 （2）做绝对定位的参考，子绝父相 相对定位的定位值 left：盒子右移 right：盒子左移 top：盒子下移 bottom：盒子上移 PS：负数表示相反的方向。 ↘： 123position: relative;left: 40px;top: 10px; ↙： 123position: relative;right: 100px;top: 100px; ↖： 123position: relative;right: 100px;bottom: 100px; 绝对定位这个可以参考github前端学习 绝对定位：定义横纵坐标。原点在父容器的左上角或左下角。横坐标用left表示，纵坐标用top或者bottom表示。 格式举例如下： 123position: absolute; /*绝对定位*/left: 10px; /*横坐标*/top/bottom: 20px; /*纵坐标*/ 绝对定位脱标绝对定位的盒子脱离了标准文档流。 所以，所有的标准文档流的性质，绝对定位之后都不遵守了。 绝对定位之后，标签就不区分所谓的行内元素、块级元素了，不需要display:block就可以设置宽、高了。 绝对定位的参考点（重要）（1）如果用top描述，那么参考点就是页面的左上角，而不是浏览器的左上角： （2）如果用bottom描述，那么参考点就是浏览器首屏窗口尺寸（好好理解“首屏”二字），对应的页面的左下角： “首屏”就是页面没卷动时的第一页，用bottom的定位的时候，参考的是浏览器首屏大小对应的页面左下角。 以盒子为参考点一个绝对定位的元素，如果父辈元素中也出现了已定位（无论是绝对定位、相对定位，还是固定定位）的元素，那么将以父辈这个元素，为参考点。 以下几点需要注意。 （1） 要听最近的已经定位的祖先元素的，不一定是父亲，可能是爷爷： 123456&lt;div class=&quot;box1&quot;&gt; 相对定位 &lt;div class=&quot;box2&quot;&gt; 没有定位 &lt;p&gt;&lt;/p&gt; 绝对定位，将以box1为参考，因为box2没有定位，box1就是最近的父辈元素 &lt;/div&gt;&lt;/div&gt; 再比如： 12345&lt;div class=&quot;box1&quot;&gt; 相对定位 &lt;div class=&quot;box2&quot;&gt; 相对定位 &lt;p&gt;&lt;/p&gt; 绝对定位，将以box2为参考，因为box2是自己最近的父辈元素 &lt;/div&gt;&lt;/div&gt; （2）不一定是相对定位，任何定位，都可以作为儿子的参考点： 子绝父绝、子绝父相、子绝父固，都是可以给儿子定位的。但是在工程上，如果子绝、父绝，没有一个盒子在标准流里面了，所以页面就不稳固，没有任何实战用途。 工程应用： “子绝父相”有意义：这样可以保证父亲没有脱标，儿子脱标在父亲的范围里面移动。于是，工程上经常这样做： 父亲浮动，设置相对定位（零偏移），然后让儿子绝对定位一定的距离。 （3）绝对定位的儿子，无视参考的那个盒子的padding： 父亲div的padding，p是div的内容区域。此时，如果div相对定位，p绝对定位，那么，p将无视父亲的padding，在border内侧为参考点，进行定位 工程应用： 绝对定位非常适合用来做“压盖”效果。 让绝对定位中的盒子在父亲里居中 我们知道，如果想让一个标准流中的盒子在父亲里居中（水平方向看），可以将其设置margin: 0 auto属性。 可如果盒子是绝对定位的，此时已经脱标了，如果还想让其居中（位于父亲的正中间），可以这样做： 12345678div { width: 600px; height: 60px; position: absolute; 绝对定位的盒子 left: 50%; 首先，让左边线居中 top: 0; margin-left: -300px; 然后，向左移动宽度（600px）的一半} 如上方代码所示，我们先让这个宽度为600px的盒子，左边线居中，然后向左移动宽度（600px）的一半，就达到效果了。 我们可以总结成一个公式： left:50%; margin-left:负的宽度的一半 固定定位固定定位：就是相对浏览器窗口进行定位。无论页面如何滚动，这个盒子显示的位置不变。 用途1：网页右下角的“返回到顶部” 比如我们经常看到的网页右下角显示的“返回到顶部”，就可以固定定位。 123456789101112131415&lt;style type=&quot;text/css&quot;&gt; .backtop{ position: fixed; bottom: 100px; right: 30px; width: 60px; height: 60px; background-color: gray; text-align: center; line-height:30px; color:white; text-decoration: none; /*去掉超链接的下划线*/ } &lt;/style&gt; 用途2：顶部导航条 我们经常能看到固定在网页顶端的导航条，可以用固定定位来做。 需要注意的是，假设顶部导航条的高度是60px，那么，为了防止其他的内容被导航条覆盖，我们要给body标签设置60px的padding-top。 顶部导航条的实现如下： 顶部导航 >folded1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xml:lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; *{ margin: 0; padding: 0; }body{ /*为什么要写这个？*/ /*不希望我们的页面被nav挡住*/ padding-top: 60px; /*IE6不兼容固定定位，所以这个padding没有什么用，就去掉就行了*/ _padding-top:0; } .nav{ position: fixed; top: 0; left: 0; width: 100%; height: 60px; background-color: #333; z-index: 99999999; } .inner_c{ width: 1000px; height: 60px; margin: 0 auto; } .inner_c ul{ list-style: none; } .inner_c ul li{ float: left; width: 100px; height: 60px; text-align: center; line-height: 60px; } .inner_c ul li a{ display: block; width: 100px; height: 60px; color:white; text-decoration: none; } .inner_c ul li a:hover{ background-color: gold; } p{ font-size: 30px; } .btn{ display: block; width: 120px; height: 30px; background-color: orange; position: relative; top: 2px; left: 1px; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;nav&quot;&gt; &lt;div class=&quot;inner_c&quot;&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;网页栏目&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;网页栏目&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;网页栏目&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;网页栏目&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;网页栏目&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;网页栏目&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;网页栏目&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;网页栏目&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;网页栏目&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;网页栏目&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; z-index属性：z-index属性：表示谁压着谁。数值大的压盖住数值小的。 有如下特性： （1）属性值大的位于上层，属性值小的位于下层。 （2）z-index值没有单位，就是一个正整数。默认的z-index值是0。 （3）如果大家都没有z-index值，或者z-index值一样，那么在HTML代码里写在后面，谁就在上面能压住别人。定位了的元素，永远能够压住没有定位的元素。 （4）只有定位了的元素，才能有z-index值。也就是说，不管相对定位、绝对定位、固定定位，都可以使用z-index值。而浮动的元素不能用。 （5）从父现象：父亲怂了，儿子再牛逼也没用。意思是，如果父亲1比父亲2大，那么，即使儿子1比儿子2小，儿子1也能在最上层。 z-index属性的应用还是很广泛的。当好几个已定位的标签出现覆盖的现象时，我们可以用这个z-index属性决定，谁处于最上方。也就是层级的应用。 层级： （1）必须有定位（除去static） （2）用z-index来控制层级数。 CSS floatcss中一共有三种手段，使一个元素脱离标准文档流： （1）浮动 （2）绝对定位 （3）固定定位 浮动的性质浮动是css里面布局用的最多的属性。 浮动的元素脱标 脱标即脱离标准流。一旦一个元素浮动了，那么，将能够并排了，并且能够设置宽高了。无论它原来是个div还是个span。所有标签，浮动之后，已经不区分行内、块级了。 浮动的元素互相贴靠 我们给三个div均设置了float: left;属性之后，然后设置宽高。当改变浏览器窗口大小时，div的贴靠效果：如果有足够空间，那么就会靠着。如果没有足够的空间，去贴左墙。 浮动的元素有“字围”效果 让div浮动，p不浮动。div挡住了p，但不会挡住p中的文字，形成“字围”效果。标准流中的文字不会被浮动的盒子遮挡住。（文字就像水一样）关于浮动，为避免混乱，我们在初期一定要遵循一个原则：永远不是一个东西单独浮动，浮动都是一起浮动，要浮动，大家都浮动。 收缩 收缩：一个浮动的元素，如果没有设置width，那么将自动收缩为内容的宽度（这点非常像行内元素）。 CSS样式表与选择器样式表插入样式表的方法有三种: 外部样式表(External style sheet) 内部样式表(Internal style sheet) 内联样式(Inline style) 外部样式表外部样式表1&lt;head&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;mystyle.css&quot;&gt; &lt;/head&gt; 浏览器会从文件 mystyle.css 中读到样式声明，并根据它来格式文档。 外部样式表可以在任何文本编辑器中进行编辑。文件不能包含任何的 html 标签。样式表应该以 .css 扩展名进行保存。 内部样式表当单个文档需要特殊的样式时，就应该使用内部样式表。你可以使用 &lt;style&gt; 标签在文档头部定义内部样式表，就像这样: 内部样式表1234567&lt;head&gt; &lt;style&gt; hr {color:sienna;} p {margin-left:20px;} body {background-image:url(&quot;images/back40.gif&quot;);} &lt;/style&gt; &lt;/head&gt; 内联样式由于要将表现和内容混杂在一起，内联样式会损失掉样式表的许多优势，当样式仅需要在一个元素上应用一次时。要使用内联样式，你需要在相关的标签内使用样式（style）属性。Style 属性可以包含任何 CSS 属性。本例展示如何改变段落的颜色和左外边距： 内联样式1&lt;p style=&quot;color:sienna;margin-left:20px&quot;&gt;这是一个段落。&lt;/p&gt; 多重样式以及优先级一般情况下，优先级如下： （内联样式）Inline style &gt; （内部样式）Internal style sheet &gt;（外部样式）External style sheet &gt; 浏览器默认样式 多重样式123456789101112&lt;head&gt; &lt;!-- 外部样式 style.css --&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;style.css&quot;/&gt; &lt;!-- 设置：h3{color:blue;} --&gt; &lt;style type=&quot;text/css&quot;&gt; /* 内部样式 */ h3{color:green;} &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h3&gt;测试！&lt;/h3&gt; &lt;/body&gt; 一般我也不用，用的时候可以查，关于样式表、选择器优先级，有对应的计算公式给出，服务于多个css选择器作用，即为“层叠式”，查阅CSS样式优先级。 选择器CSS 选择器：就是指定 CSS 要作用的标签，那个标签的名称就是选择器。意为：选择哪个容器。 CSS 的选择器分为两大类：基本选择题和扩展选择器。 基本选择器： 标签选择器：针对一类标签 ID 选择器：针对某一个特定的标签使用 类选择器：针对你想要的所有标签使用 通用选择器（通配符）：针对所有的标签都适用（不建议使用） 标签选择器标签选择器，选择的是页面上所有这种类型的标签，所有的标签，都可以是选择器。比如 ul、li、label、dt、dl、input。无论这个标签藏的多深，一定能够被选择上。 1p{ font-size:14px; } ID 选择器：规定用#来定义，针对某一个特定的标签来使用，只能使用一次。css 中的 ID 选择器以”#”来定义。 123456&lt;style&gt; #mytitle{ border:3px dashed green; }&lt;/style&gt;&lt;body&gt; &lt;h1 id=&quot;mytitle&quot;&gt;&lt;/h1&gt;&lt;/body&gt; 类选择器：规定用圆点.来定义，针对你想要的所有标签使用。优点：灵活。css 中用.来表示类。类选择器可以被多种标签使用，同一个标签也可以使用多个类选择器。用空格隔开。 1234.css.one{ width:800px; }&lt;h1 class=one&gt; &lt;/h1&gt; 关于id与类，类上样式，id 上行为，id 是 js 用的。js 要通过 id 属性得到标签，所以 css 层面尽量不用 id，另一层面，我们会认为一个有 id 的元素，有动态效果。 通配符*，匹配任何标签，不建议用。 高级选择器后代、交集、并集选择器。我就写个博客玩，不写前端，先不学了。doge.jpg 好像还是得用一下，写一点吧。 后代：用空格隔开，表示所有属于 E 元素后代的 F 元素，有这个样式。 12345678&lt;style type=&quot;text/css&quot;&gt; h3 b i { color: red; } .div1 p { color: red; }&lt;/style&gt; 空格就表示后代。定义了&lt;h3&gt;标签中的&lt;b&gt;标签中的&lt;i&gt;标签的样式。h3 和 b 和 i 标签不一定是连续紧挨着的，只要保持一个后代的关联即可。即不一定要是儿子。里面可以包含类以及id选择器。只是表示一种祖先结构。 交集：定义交集选择器的时候，两个选择器之间紧密相连。一般是以标签名开头，比如div.haha，再比如p.special。如果后一个选择器是类选择器，则写为div.special；如果后一个选择器 id 选择器，则写为div#special。 123h3.special { color: red;} 选择的元素要求同时满足两个条件：必须是 h3 标签，然后必须是 special 标签。 并集：定义的时候用逗号隔开 123p,h1,#mytitle,.one { color: red;} 则上述标签都会被渲染。 伪类（伪类选择器）伪类：同一个标签，根据其不同的种状态，有不同的样式。这就叫做“伪类”。伪类用冒号来表示。 比如div是属于box类，这一点很明确，就是属于box类。但是a属于什么类？不明确。因为需要看用户点击前是什么状态，点击后是什么状态。所以，就叫做“伪类”。 静态伪类和动态伪类伪类选择器分为两种。 （1）静态伪类：只能用于超链接的样式。如下： :link 超链接点击之前 :visited 链接被访问过之后 PS：以上两种样式，只能用于超链接。 （2）动态伪类：针对所有标签都适用的样式。如下： :hover “悬停”：鼠标放到标签上的时候 :active “激活”： 鼠标点击标签，但是不松手时。 :focus 是某个标签获得焦点时的样式（比如某个输入框获得焦点） 超链接a标签超链接的四种状态 a标签有4种伪类（即对应四种状态），要求背诵。如下： :link “链接”：超链接点击之前 :visited “访问过的”：链接被访问过之后 :hover “悬停”：鼠标放到标签上的时候 :active “激活”： 鼠标点击标签，但是不松手时。 对应的代码如下： 123456789101112131415161718192021&lt;style type=&quot;text/css&quot;&gt; /*让超链接点击之前是红色*/ a:link{ color:red; } /*让超链接点击之后是绿色*/ a:visited{ color:orange; } /*鼠标悬停，放到标签上的时候*/ a:hover{ color:green; } /*鼠标点击链接，但是不松手的时候*/ a:active{ color:black; }&lt;/style&gt; 在css中，这四种状态必须按照固定的顺序写： a:link 、a:visited 、a:hover 、a:active CSS特性继承： 关于文字样式的属性，都具有继承性。这些属性包括：color、 text-开头的、line-开头的、font-开头的。 关于盒子、定位、布局的属性，都不能继承。 层叠： 计算权重和就近。 写点小网站就不用管了，反正都是硬编码。 CSS盒模型盒模型，英无论是div、span、还是a都是盒子。但是，图片、表单元素一律看作是文本，它们并不是盒子。这个很好理解，比如说，一张图片里并不能放东西，它自己就是自己的内容。 一个盒子中主要的属性就5个：width、height、padding、border、margin。如下： width和height：内容的宽度、高度（不是盒子的宽度、高度）。 padding：内边距。 border：边框。 margin：外边距。 不写了，一张图的事。 paddingpadding是4个方向的，所以我们能够分别描述4个方向的padding。 方法有两种，第一种写小属性；第二种写综合属性，用空格隔开。 小属性的写法： 1234padding-top: 30px;padding-right: 20px;padding-bottom: 40px;padding-left: 100px; 综合属性的写法：(上、右、下、左)（顺时针方向，用空格隔开。margin的道理也是一样的） 1padding:30px 20px 40px 100px; 如果写了四个值，则顺序为：上、右、下、左。 如果只写了三个值，则顺序为：上、右、下。左和右一样。 如果只写了两个值，比如说： 1padding: 30px 40px; 则顺序等价于：30px 40px 30px 40px; 用小属性层叠大属性。比如： 12padding: 20px;padding-left: 30px; 则左30，上右下20。 下面的写法： 12padding-left: 30px;padding: 20px; 第一行的小属性无效，因为被第二行的大属性层叠掉了。 borderborder就是边框。边框有三个要素：像素（粗细）、线型、颜色。 12345.div1{ width: 10px; height: 10px; border: 2px solid red;} 颜色如果不写，默认是黑色。另外两个属性如果不写，则无法显示边框。 border属性是能够被拆开的，有两大种拆开的方式： （1）按三要素拆开：border-width、border-style、border-color。（一个border属性是由三个小属性综合而成的） （2）按方向拆开：border-top、border-right、border-bottom、border-left。 一个border属性，是由三个小属性综合而成的。如果某一个小属性后面是空格隔开的多个值，那么就是上右下左的顺序。举例如下： 123border-width:10px 20px;border-style:solid dashed dotted;border-color:red green blue yellow; 练习用border画三角形。 Sass 一日游两种后缀名（两种语法）sass 有两种后缀名文件： （1）.sass：对空格敏感。不使用大括号和分号，所以每个属性之间是通过换行来分隔。 比如： 123h1 color: #000 background: #fff 这种语法是类ruby的语法，和CSS的语法相比，相差较大。所以，在3.0版本中就引入了.scss的语法。 （2）.scss：是css语法的超集，可以使用大括号和分号。 比如： 1234h1 { color: #000; background: #fff;} 注意：一个项目中可以混合使用两种语法，但是一个文件中不能同时使用两种语法。 两种格式之间的转换： 我们在工程目录下新建main.scss，输入如下代码： 1234*{ margin: 0; padding: 0;} 然后输入如下命令，就可以将上面的main.scss转化为main.sass： 1sass-convert main.scss main.sass 打开生成的main.sass，内容如下： 1234* margin: 0 padding: 0 变量语法Sass 是通过$符号来声明变量。 （1）我们新建一个文件_variables.scss，这个文件专门用来存放变量，然后在其他的文件中引入_variables.scss即可。 因为这个文件只需要存储变量，并不需要它编译出对应的 css 文件，所以我们给文件名的前面加了下划线，意思是声明为局部文件。 我们在这个文件中，声明两个字体变量： 123$font1: Braggadocio, Arial, Verdana, Helvetica, sans-serif;$font2: Arial, Verdana, Helvetica, sans-serif; （2）新建文件main.scss，在里面引入步骤（1）中的变量文件： 123456789@import &quot;variables&quot;; // 引入变量文件.div1{ font-family: $font1;}.div2{ font-family: $font2;} 基于 Sass 的既定规则： 没有文件后缀名时，Sass 会自动添加 .scss 或者 .sass 的后缀（具体要看已经存在哪个后缀的文件）。 同一目录下，局部文件和非局部文件不能重名。 对应生成的main.css文件如下： main.css 12345678910/* line 9, ../sass/main.scss */.div1 { font-family: Braggadocio, Arial, Verdana, Helvetica, sans-serif;}/* line 13, ../sass/main.scss */.div2 { font-family: Arial, Verdana, Helvetica, sans-serif;} 注释语法单行注释： 1//我是单行注释 块级注释： 12345/* 我是块级注释 哈哈*/ 二者的区别是：单行注释不会出现在自动生成的css文件中。","link":"/2019/10/09/css%E7%AC%94%E8%AE%B0/"},{"title":"塞尔达开荒流程","text":"塞尔达开荒流程以及攻略。 初始能力获取初始台地四神庙： 1、宝箱拿衣服国王房子（貌似要开全神庙离开台地），2、兽肉（野猪）鲈鱼、辣椒（暖暖草果）（雪山怪物据点下）做成料理（火辣海陆煎烤）给国王，3、强行爬到到山顶。 或者强制手持（方弹放地上，收回武器同时卸盾，捡炸弹扔掉） 磁力炸弹时停冰 血量耐力兑换一颗心或耐力，解锁一个回忆。前往哈特诺村神庙。 共37个。需要720卢比。 进入神庙，自动存档，原路出神庙 寄存心心或耐力后手动保存一个存档 读取出神庙后的自动档，进入神庙 平台机关，相机。按住防御（ZL），同时按下L（启动相机）与左摇杆（蹲下） 仍能调查，按A调查出现照片 删除照片，快速快速快速按+打开背包手持物品查看回忆，无法读取，返回，可以控制平台 成功，读取手动档，血还在，寄存也还在 回忆地图 位置 全塔打开平原之塔、丘陵、双子山、哈特诺之塔。费罗尼、拉涅尔 白马与马具先随便抓一只：去圣山找耐力药原料 备好冰箭，约两轮耐力，初始冰箭位置，初始台地精灵之森沼泽，造冰。 ![image-20200614232633561](D:\\CSlearning\\blog essay\\游\\image-20200614232633561.png) 平原之塔平原外围驿站 完成任务获得皇家马具 古代马具：马鞍：马神泉（湖塔） 缰绳：圣山樱花树（丘陵） 满心料理满耐力料理丘陵之塔：圣山：榴莲苹果耐力萝卜。 费罗尼：榴莲 魔吉拉面具顺便把石头人打了 大精灵之泉先开卡卡利科村100卢比（100，500，1000，10000） 第二个大妖精西莎在塔邦挞，“塔邦挞之塔”往南。500卢比，在塔邦挞大桥马宿找一个寻找大妖精之泉的NPC，会送500卢比 马神泉1000 拍照哈特诺古代研究所，强持。 发展圣山采矿，苹果、松露、萝卜榴莲、毅力蘑菇，（拍卢比兔 ） 沙地靴，雪地靴格鲁德高地八位英雄和剑，拍照 雷鸣头盔解放雷兽，完成支线 10个树莓（小女孩），一个榴莲（去沙漠大妖精给）（兵营卫兵），10个打火石（首饰店），莫尔德拉吉克的肝脏（兵营卫兵） 橡胶套害怕打雷支线任务（费罗尼） 神庙一：托.雅萨（丘陵之塔）雷台之地神庙 神庙二：丘卡.纳塔（费罗尼） 卓拉套、火山套、女装、防寒套卓拉套：国王、国王右侧看向碎脊点的红色人鱼的拍莱尼尔任务，领地背后的托托湖底 火山套：先马厩买药剂进去150（一支60，一支差不多也够了），南部矿区抓十只耐火蜥蜴换衣服省600，鼓隆商店防火服2700 女装：镇上神庙旁触发女装男人，绿洲最高处夸赞他，600买到 防寒套2150 幻影套、盖侬套、蛮族套幻影套：竞技场、祭奠场、海拉鲁驻军遗址 盖侬套：腿，石头底；头，瀑布底；衣服，桥底 蛮族套：三个迷宫神庙宝箱（阿卡莱，黑布拉，荒野格鲁德） 雷龙角刷钱四英杰及英杰之诗、摩托车 风：射4个靶，滑雪，射龙角（早上） 火：石巨人，火山飞翔，站岩浆里 水：早上飞进海里，爬瀑布，打守护者 风：打大沙鱼，盾滑，偷宝珠扔洞里 导师：速攻（时停），分身（电，爆炸箭），巨大（盾反，电） 希卡石板时停升级三个古轴，古代钉，核心 传送阵（阿卡莱）迷宫岛宝箱 城堡武器海利亚盾（牢房解锁，建设一始村）建议白银后SL出144，近卫武器，近卫套装 塔尖有古代箭、呀哈哈 近卫套装警卫室，入口墙内，炸开有宝箱：古代箭 近卫室宝箱裤子 餐厅中门进去直走木门出去 炸开尽头左侧石墙开宝箱衣服 帽子在主殿。 属性武器主城大部分都有 解放四神兽后的竞技场 腐朽的古树和奥尔丁大化石有火剑 远程弓（一心弓格鲁德弓）哈特诺塔附近的据点哨兵 格鲁德军营 背包格子找到伯库林。卡卡利科村的路上，打怪夺回沙锤。 升级两次后，回家，迷路，出现在森林驿站 五次后回家，在科洛格森林 武器1、2、3、5、8、12、17、25、35、45、55。 弓箭1、2、3、5、8、12、17、25。 盾牌1、2、3、4、5、10、10、10、10、10、15、15、15、15、15、20。 共441. 呀哈哈面具快到双火炬的地方 ![image-20200618220255256](D:\\CSlearning\\blog essay\\游\\image-20200618220255256.png) 装备升级![image-20200618214159697](D:\\CSlearning\\blog essay\\游\\image-20200618214159697.png) ![image-20200619203942444](D:\\CSlearning\\blog essay\\游\\image-20200619203942444.png) ![image-20200619204033020](D:\\CSlearning\\blog essay\\游\\image-20200619204033020.png) ![image-20200619204120140](D:\\CSlearning\\blog essay\\游\\image-20200619204120140.png) ![image-20200619204135698](D:\\CSlearning\\blog essay\\游\\image-20200619204135698.png) 回忆 房子、装修、一始村30木柴 4400卢比 一始村：110木柴，南部矿场，卡拉卡拉集市（别女装），利特村，卓拉二层 资源怪物商人阿卡莱骷髅池塘触发 达基基神庙一出来就是（塞拉瀑布，桥底祭祀之枪或老婆枪空中下刺） 驿站商人 旅行商人1 贝黎斯晴天：古代螺丝1 古代弹簧1 古代齿轮1雨天：古代螺丝1 古代弹簧1 古代齿轮1 古代传动轴1 古代核心1 2 帕拉斯加晴天：山羊黄油2 鲜奶2 禽蛋*2雨天：价格下降 3 布古力晴天：精力独角仙1 精力鲈鱼1 精力蘑菇3 精力螃蟹3雨天：毅力蘑菇3 毅力胡萝卜1 毅力蛙*1 4 本戈晴天：兽肉3 高级兽肉1 禽肉3 高级禽肉1 岩盐3雨天：兽肉3 高级兽肉3 顶级兽肉1 高级禽肉1 岩盐3 5 基洛丘晴天：生命松露2 速速胡萝卜3 精力蘑菇3 岩盐5 木箭5雨天：木箭5 速速紫罗兰2 生命松露2 大个生命松露1 岩盐5 6 秋明晴天：椰子5 生命榴莲5 大剑鲷鱼3 铠甲鲷鱼3 精力螃蟹3雨天：椰子5 生命榴莲5 大剑鲷鱼3 铠甲鲷鱼3 生命海螺3 7 康波晴天：兽肉2 速速胡萝卜3 铠甲南瓜3 生命松露2雨天：兽肉3 高级兽肉2 铠甲南瓜3 生命松露2 大个生命松露*1 8 麦茨晴天：高级兽肉2 大剑蘑菇1 暖暖鳟鱼1 速速莲蓬1雨天：顶级兽肉2 铠甲南瓜2 暖暖鳟鱼2 速速莲蓬2 鼓隆的调味粉*1 9 伍德晴天：木箭1 木箭5 火箭1 火箭5雨天：木箭1 木箭10 火箭1 火箭5 冰箭*5 10 姆娅晴天：塔邦达小麦10 海拉鲁米5 山羊黄油5 禽蛋5雨天：塔邦达小麦10 海拉鲁米5 鲜奶10 蔗糖5 鼓隆的调味粉*5 11 艾纳西迈晴天：冰冷蘑菇3 暖暖蘑菇3 酥麻蘑菇3 精力蘑菇1雨/雪天：大剑蘑菇3 铠甲蘑菇3 毅力蘑菇3 生命松露2 大个生命松露*1 12 吉宁（须骑马对话，在骑马演武处）晴天：木箭◊105 木箭◊55 木箭10 炸弹箭5雨天：木箭◊105 木箭◊55 木箭10 电箭5 13 马平由于沙漠与火山均不下雨，故无货物变动暖暖蜻蜓3 冰冷蜻蜓3 14 伽拉顿木箭20 苹果10 橡子10 精力蚱蜢5 15 恰里奥琥珀1 蛋白石1 黄玉1 红宝石1 蓝宝石*1 圣山 补：达拉伊特森林有生命萝卜、独角仙哪里有很多品种的蘑菇、以及冰蝴蝶 初始台地其他资源聚集地爆炸箭刷 火箭森林之塔哨兵 北部矿区火蜥蜴冰秒 冰箭阿卡莱、拉涅尔塔哨兵 电箭城堡神庙三只蜥蜴 BOSS大鲨鱼 剑之试炼初级（扇子斧头） 一层猪猪怪群：直接跳放炸弹（箱子有材料，传送点旁的大树有鸟蛋）【大师：树枝引火烧箱子引过去烧死】 二层火丘丘猪猪据点加箭塔：锁哨兵投矛爆丘丘飞到据点大风车【大师据点有铁锤】 三层丘丘，火丘丘：炸一个，中心大风车砸地群伤，起飞射箭 四层大据点：锁射箭解决二层哨兵，爬梯打怪，飞下去偷袭 五层两只大怪，一个骷髅头据点：炸两个大怪，再爬后面炸火药桶【偷袭，炸】 六层石头人：锤，时停锤 七层：抓一只小精灵，炸树拿大叶子 八层小蜥蜴据点+两只单只蜥蜴：偷袭、大风车 九层两只章鱼一只小电法师：射章鱼，时停打法师 十层三只蜥蜴，一只哨兵，两只高级：马上下水绕右射哨兵，背刺【直冲，锁，爆头秒，偷袭，爬鱼骨可以躲】 十一层两只猪猪哨兵，两只高级猪猪哨兵，大据点：制冰跳射，高级怪捅下水 十二层西诺克斯：随便扔东西 高阶（陨石杖雷杖专注弓斧头） 一层5只猪猪：跳炸，打箱子 二层两只法师，猪猪：爆头秒法师 三层视野共享哨兵，猪猪若干：起跳林克时间解决哨兵，爆炸箭冰箭带上【拿26弓，飞镖，在两猪据点】 四层残废守护者：盾反或者近身射眼打，宝箱骑士盾 五层补给：抓精灵 六层电球，火蝙蝠：射电球，长矛打蝙蝠 七层两只火蜥蜴哨兵，骷髅据点：哨兵蹲下用专注弓冰箭秒，射灯炸补爆炸箭 八层火法师，3只猪猪：绕左爬墙跳林克时间冰箭秒法师，陨石杖快速清怪，骑墙射怪 九层守护者：盾反 十层独眼巨人木护腿 十一层 两个精灵 十二层六只小守护者：制冰挡住围攻 十三层三守护者：陨石杖解决，墙上铁箱后宝箱 十四层四小守护者两中等守护者：制冰一心弓打小守护者，陨石杖或长矛推下水大守护者 十五层两只试炼守护者：陨石杖雷杖 十六层终极守卫者： 终阶（生锈剑骷髅蜥蜴大骨头开瓶器、古代箭，准备十多捆柴，元素武器） 【一段雷雨骷髅怪，二段火山，三段雪山】 一层四只小骷髅：跳炸，长矛捅 二层两电蝙蝠，骷髅据点（三只骨蜥蜴）：炸一只制冰跳射一只，不要炸炸药桶，箱子里有高级肉，地下宝箱近卫剑 三层两只电丘丘，骨蜥蜴：宝箱有 四层骑马小骷髅：平台引怪林克时间射头 五层西诺克斯：开元素剑，地下箱子有冰箭，【骨头插着近卫剑】 六层补给 一只精灵、松露，三发古代箭 七层章鱼，小石头，小火丘丘：吸剑 八层三只火蜥蜴： 九层法师，骷髅据点（2火蜥蜴，大猪）：时停冰剑/冰箭秒法师、蜥蜴【据点里有近卫盾剑】 十层大据点：熔岩里宝箱古代箭，【底层墙角近卫剑】，电剑缴械 十一层石头人：炸开气流口 十二层补给 两只精灵，做抗寒菜，生命萝卜 十三层冰球球，小石头，三只猪：砍柴融冰拿爆炸箭，丘丘冻住猪猪，爆头带走，白银爆头偷袭 十四层冰蜥蜴，大据点：秒哨兵，秒冰蜥蜴。融冰古代箭，古代箭带走黄金大猪 十五层法师，小篝火，白银大猪：时停/爬墙火箭秒法师，古代箭带走黄金猪 十六层石头人：融冰开气流口 十七层人马：古代箭融冰爆炸箭【左边兽神剑】 十八层三只精灵 十九层盾反守护者【激活顺路打】 二十层地面守卫者一只而已 二十一层飞行守卫古代箭射眼睛 二十二层三支箭【守卫型用兽神打，省箭】 二十三速度古代箭秒人马打守卫林克时间清小怪 bug&amp;操作技巧盾跳冰台跳吹哨跑刷血拉弓转回旋五连斩后摇取消布偶跳BTB强制手持无限袭步风弹武器增殖耐久继承","link":"/2020/06/19/zelda%E9%87%8E%E5%90%B9%E5%BC%80%E8%8D%92/"}],"tags":[{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"blog","slug":"blog","link":"/tags/blog/"},{"name":"github","slug":"github","link":"/tags/github/"},{"name":"cs","slug":"cs","link":"/tags/cs/"},{"name":"front-end","slug":"front-end","link":"/tags/front-end/"},{"name":"docker","slug":"docker","link":"/tags/docker/"},{"name":"docker-app","slug":"docker-app","link":"/tags/docker-app/"},{"name":"book","slug":"book","link":"/tags/book/"},{"name":"test","slug":"test","link":"/tags/test/"},{"name":"python","slug":"python","link":"/tags/python/"},{"name":"nonebot","slug":"nonebot","link":"/tags/nonebot/"},{"name":"tool","slug":"tool","link":"/tags/tool/"},{"name":"IME","slug":"IME","link":"/tags/IME/"},{"name":"note","slug":"note","link":"/tags/note/"},{"name":"game","slug":"game","link":"/tags/game/"},{"name":"Jmahjong","slug":"Jmahjong","link":"/tags/Jmahjong/"},{"name":"zelda","slug":"zelda","link":"/tags/zelda/"}],"categories":[{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"cs","slug":"cs","link":"/categories/cs/"},{"name":"blog","slug":"blog","link":"/categories/blog/"},{"name":"git","slug":"cs/git","link":"/categories/cs/git/"},{"name":"docker","slug":"cs/docker","link":"/categories/cs/docker/"},{"name":"github","slug":"cs/github","link":"/categories/cs/github/"},{"name":"front-end","slug":"cs/front-end","link":"/categories/cs/front-end/"},{"name":"test","slug":"test","link":"/categories/test/"},{"name":"python","slug":"cs/python","link":"/categories/cs/python/"},{"name":"tool","slug":"tool","link":"/categories/tool/"},{"name":"note","slug":"note","link":"/categories/note/"},{"name":"docker-app","slug":"cs/docker/docker-app","link":"/categories/cs/docker/docker-app/"},{"name":"book","slug":"book","link":"/categories/book/"},{"name":"game","slug":"game","link":"/categories/game/"},{"name":"mahjong","slug":"game/mahjong","link":"/categories/game/mahjong/"},{"name":"zelda","slug":"game/zelda","link":"/categories/game/zelda/"}]}